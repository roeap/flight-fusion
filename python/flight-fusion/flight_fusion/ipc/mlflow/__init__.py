# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: mlflow/databricks.proto, mlflow/databricks_artifacts.proto, mlflow/model_registry.proto, mlflow/service.proto
# plugin: python-betterproto
import warnings
from dataclasses import dataclass
from typing import Dict, List, Optional

import betterproto
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase


class Visibility(betterproto.Enum):
    """Visibility defines who is allowed to use the RPC."""

    # Public indicates visible to both external and internal customers.
    PUBLIC = 1
    # Internal is only available to Databricks-internal clients.
    INTERNAL = 2
    # Public-undocumented are accessible via public endpoints, but not
    # documented. This is useful for internal clients that depend on public
    # endpoints (e.g. workflows running in the driver).
    PUBLIC_UNDOCUMENTED = 3


class ErrorCode(betterproto.Enum):
    # Internal, system-level error codes, which generally cannot be resolved by
    # the user, but instead are due to service issues. Generic internal error
    # occurred.
    INTERNAL_ERROR = 1
    # An internal system could not be contacted due to a period of
    # unavailability.
    TEMPORARILY_UNAVAILABLE = 2
    # Indicates that an IOException has been internally thrown.
    IO_ERROR = 3
    # The request is invalid.
    BAD_REQUEST = 4
    # Common application-level error codes, which were caused by the user input
    # but may be returned by multiple services. Supplied value for a parameter
    # was invalid (e.g., giving a number for a string parameter).
    INVALID_PARAMETER_VALUE = 1000
    # Indicates that the given API endpoint does not exist.
    ENDPOINT_NOT_FOUND = 1001
    # Indicates that the given API request was malformed.
    MALFORMED_REQUEST = 1002
    # If one or more of the inputs to a given RPC are not in a valid state for
    # the action.
    INVALID_STATE = 1003
    # If a given user/entity doesn't have the required permission(s) to perform
    # an action
    PERMISSION_DENIED = 1004
    # If a given user/entity is trying to use a feature which has been disabled
    FEATURE_DISABLED = 1005
    # If customer-provided credentials are not authorized to perform an operation
    CUSTOMER_UNAUTHORIZED = 1006
    # If the API request is rejected due to throttling
    REQUEST_LIMIT_EXCEEDED = 1007
    # If the user attempts to perform an invalid state transition on a shard.
    INVALID_STATE_TRANSITION = 2001
    # Unable to perform the operation because the shard was locked by some other
    # operation.
    COULD_NOT_ACQUIRE_LOCK = 2002
    # Operation was performed on a resource that already exists.
    RESOURCE_ALREADY_EXISTS = 3001
    # Operation was performed on a resource that does not exist.
    RESOURCE_DOES_NOT_EXIST = 3002
    QUOTA_EXCEEDED = 4001
    MAX_BLOCK_SIZE_EXCEEDED = 4002
    MAX_READ_SIZE_EXCEEDED = 4003
    DRY_RUN_FAILED = 5001
    # Cluster request was rejected because it would exceed a resource limit.
    RESOURCE_LIMIT_EXCEEDED = 5002
    DIRECTORY_NOT_EMPTY = 6001
    DIRECTORY_PROTECTED = 6002
    MAX_NOTEBOOK_SIZE_EXCEEDED = 6003


class ArtifactCredentialType(betterproto.Enum):
    """The type of a given artifact access credential"""

    # The credential is an Azure Shared Access Signature URI. For more
    # information, see https://docs.microsoft.com/en-
    # us/azure/storage/common/storage-sas-overview
    AZURE_SAS_URI = 1
    # The credential is an AWS Presigned URL. For more information, see https://d
    # ocs.aws.amazon.com/AmazonS3/latest/dev/ShareObjectPreSignedURL.html
    AWS_PRESIGNED_URL = 2
    # The credential is a GCP Signed URL. For more information, see
    # https://cloud.google.com/storage/docs/access-control/signed-urls
    GCP_SIGNED_URL = 3


class ModelVersionStatus(betterproto.Enum):
    # Request to register a new model version is pending as server performs
    # background tasks.
    PENDING_REGISTRATION = 1
    # Request to register a new model version has failed.
    FAILED_REGISTRATION = 2
    # Model version is ready for use.
    READY = 3


class ViewType(betterproto.Enum):
    """View type for ListExperiments query."""

    # Default. Return only active experiments.
    ACTIVE_ONLY = 1
    # Return only deleted experiments.
    DELETED_ONLY = 2
    # Get all experiments.
    ALL = 3


class SourceType(betterproto.Enum):
    """Source that generated a run."""

    # Databricks notebook environment.
    NOTEBOOK = 1
    # Scheduled or Run Now job.
    JOB = 2
    # As a prepackaged project: either a Docker image or GitHub source, etc.
    PROJECT = 3
    # Local run: Using CLI, IDE, or local notebook.
    LOCAL = 4
    # Unknown source type.
    UNKNOWN = 1000


class RunStatus(betterproto.Enum):
    """Status of a run."""

    # Run has been initiated.
    RUNNING = 1
    # Run is scheduled to run at a later time.
    SCHEDULED = 2
    # Run has completed.
    FINISHED = 3
    # Run execution failed.
    FAILED = 4
    # Run killed by user.
    KILLED = 5


@dataclass(eq=False, repr=False)
class DatabricksRpcOptions(betterproto.Message):
    """
    Defines the set of options declared for every service RPC which are used to
    direct RPCs to endpoints, as well as other metadata about the RPC.
    """

    endpoints: List["HttpEndpoint"] = betterproto.message_field(1)
    # Indicates which users are allowed to initiate this RPC.
    visibility: "Visibility" = betterproto.enum_field(2)
    # Complete definition of all error codes (from a statically defined set)
    # which this method may return.
    error_codes: List["ErrorCode"] = betterproto.enum_field(3)
    # If defined, a rate limit will be applied to this RPC for all requests from
    # the API proxy.
    rate_limit: "RateLimit" = betterproto.message_field(4)
    # If defined, overrides the default title used for in the API docs. See
    # ProtobufDocGenerator for more info.
    rpc_doc_title: str = betterproto.string_field(5)


@dataclass(eq=False, repr=False)
class HttpEndpoint(betterproto.Message):
    # HTTP method like POST or GET.
    method: str = betterproto.string_field(1)
    # Conceptual path of the API, like "/clusters" or "/clusters/create". Should
    # start with a slash.
    path: str = betterproto.string_field(2)
    # A version like 1.1 which is prepended to the URL (e.g., GET /1.1/clusters).
    # Breaking changes to an RPC must use a different version number.
    since: "ApiVersion" = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class ApiVersion(betterproto.Message):
    major: int = betterproto.int32_field(1)
    minor: int = betterproto.int32_field(2)


@dataclass(eq=False, repr=False)
class RateLimit(betterproto.Message):
    """
    API rate limits applied to RPCs coming from the API Proxy. The rate limits
    are applied on a per organization basis.
    """

    # The maximum burst of API requests allowed for a single endpoint. In the
    # context of the token bucket algorithm, this constant represents the total
    # capacity of the token bucket.
    max_burst: int = betterproto.int64_field(1)
    # The maximum sustained request per second limit for a single endpoint. In
    # the context of the, token bucket algorithm, this constant represents the
    # rate at which the token bucket fills.
    max_sustained_per_second: int = betterproto.int64_field(2)


@dataclass(eq=False, repr=False)
class DocumentationMetadata(betterproto.Message):
    """
    A block of documentation that is added to the AST after parsing the
    original protocol buffer.
    """

    # The string of documentation attached to this particular item.
    docstring: str = betterproto.string_field(1)
    # The string of documentation that is *before* this item. This only makes
    # sense for top-level items such as (top-level) messages, (top-level)
    # enumerations, or services. In all other cases, this string is empty.
    lead_doc: str = betterproto.string_field(2)
    # The visibility level when the docstring was generated. The documentation
    # extractor builds multiple versions of the documentation, one for each
    # visibility level. The documentation is then generated for each visibility
    # level.
    visibility: "Visibility" = betterproto.enum_field(3)
    # The original proto path in the internal representation. This is useful when
    # performing field flattening to figure out what the original field was. One
    # example is ["jobs","Run","original_attempt_run_id"] for jobs. This path is
    # unique.
    original_proto_path: List[str] = betterproto.string_field(4)
    # The location (line number) of the start of the documentation. This is
    # required to keep the pieces of documentation sorted.
    position: int = betterproto.int32_field(5)


@dataclass(eq=False, repr=False)
class DatabricksServiceExceptionProto(betterproto.Message):
    """Serialization format for DatabricksServiceException."""

    error_code: "ErrorCode" = betterproto.enum_field(1)
    message: str = betterproto.string_field(2)
    stack_trace: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class ArtifactCredentialInfo(betterproto.Message):
    # The ID of the MLflow Run containing the artifact that can be accessed with
    # the credential
    run_id: str = betterproto.string_field(1)
    # The path, relative to the Run's artifact root location, of the artifact
    # that can be accessed with the credential
    path: str = betterproto.string_field(2)
    # The signed URI credential that provides access to the artifact
    signed_uri: str = betterproto.string_field(3)
    # A collection of HTTP headers that should be specified when uploading to or
    # downloading from the specified `signed_uri`
    headers: List["ArtifactCredentialInfoHttpHeader"] = betterproto.message_field(4)
    # The type of the signed credential URI (e.g., an AWS presigned URL or an
    # Azure Shared Access Signature URI)
    type: "ArtifactCredentialType" = betterproto.enum_field(5)


@dataclass(eq=False, repr=False)
class ArtifactCredentialInfoHttpHeader(betterproto.Message):
    # The HTTP header name
    name: str = betterproto.string_field(1)
    # The HTTP header value
    value: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class GetCredentialsForRead(betterproto.Message):
    # The ID of the MLflow Run for which to fetch artifact read credentials
    run_id: str = betterproto.string_field(1)
    # The artifact paths, relative to the Run's artifact root location, for which
    # to fetch artifact read credentials. Must not be empty.
    path: List[str] = betterproto.string_field(2)
    # Token specifying the page of credentials to fetch for large requests that
    # require pagination
    page_token: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class GetCredentialsForReadResponse(betterproto.Message):
    # Credentials for reading from the specified artifact locations
    credential_infos: List["ArtifactCredentialInfo"] = betterproto.message_field(2)
    # Token used to fetch the next page of credentials for large requests that
    # require pagination
    next_page_token: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class GetCredentialsForWrite(betterproto.Message):
    # The ID of the MLflow Run for which to fetch artifact write credentials
    run_id: str = betterproto.string_field(1)
    # The artifact paths, relative to the Run's artifact root location, for which
    # to fetch artifact write credentials. Must not be empty.
    path: List[str] = betterproto.string_field(2)
    # Token specifying the page of credentials to fetch for large requests that
    # require pagination
    page_token: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class GetCredentialsForWriteResponse(betterproto.Message):
    # Credentials for writing to the specified artifact locations
    credential_infos: List["ArtifactCredentialInfo"] = betterproto.message_field(2)
    # Token used to fetch the next page of credentials for large requests that
    # require pagination
    next_page_token: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class RegisteredModel(betterproto.Message):
    # Unique name for the model.
    name: str = betterproto.string_field(1)
    # Timestamp recorded when this ``registered_model`` was created.
    creation_timestamp: int = betterproto.int64_field(2)
    # Timestamp recorded when metadata for this ``registered_model`` was last
    # updated.
    last_updated_timestamp: int = betterproto.int64_field(3)
    # User that created this ``registered_model`` NOTE: this field is not
    # currently returned.
    user_id: str = betterproto.string_field(4)
    # Description of this ``registered_model``.
    description: str = betterproto.string_field(5)
    # Collection of latest model versions for each stage. Only contains models
    # with current ``READY`` status.
    latest_versions: List["ModelVersion"] = betterproto.message_field(6)
    # Tags: Additional metadata key-value pairs for this ``registered_model``.
    tags: List["RegisteredModelTag"] = betterproto.message_field(7)


@dataclass(eq=False, repr=False)
class ModelVersion(betterproto.Message):
    # Unique name of the model
    name: str = betterproto.string_field(1)
    # Model's version number.
    version: str = betterproto.string_field(2)
    # Timestamp recorded when this ``model_version`` was created.
    creation_timestamp: int = betterproto.int64_field(3)
    # Timestamp recorded when metadata for this ``model_version`` was last
    # updated.
    last_updated_timestamp: int = betterproto.int64_field(4)
    # User that created this ``model_version``.
    user_id: str = betterproto.string_field(5)
    # Current stage for this ``model_version``.
    current_stage: str = betterproto.string_field(6)
    # Description of this ``model_version``.
    description: str = betterproto.string_field(7)
    # URI indicating the location of the source model artifacts, used when
    # creating ``model_version``
    source: str = betterproto.string_field(8)
    # MLflow run ID used when creating ``model_version``, if ``source`` was
    # generated by an experiment run stored in MLflow tracking server.
    run_id: str = betterproto.string_field(9)
    # Current status of ``model_version``
    status: "ModelVersionStatus" = betterproto.enum_field(10)
    # Details on current ``status``, if it is pending or failed.
    status_message: str = betterproto.string_field(11)
    # Tags: Additional metadata key-value pairs for this ``model_version``.
    tags: List["ModelVersionTag"] = betterproto.message_field(12)
    # Run Link: Direct link to the run that generated this version
    run_link: str = betterproto.string_field(13)


@dataclass(eq=False, repr=False)
class CreateRegisteredModel(betterproto.Message):
    # Register models under this name
    name: str = betterproto.string_field(1)
    # Additional metadata for registered model.
    tags: List["RegisteredModelTag"] = betterproto.message_field(2)
    # Optional description for registered model.
    description: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class CreateRegisteredModelResponse(betterproto.Message):
    registered_model: "RegisteredModel" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class RenameRegisteredModel(betterproto.Message):
    # Registered model unique name identifier.
    name: str = betterproto.string_field(1)
    # If provided, updates the name for this ``registered_model``.
    new_name: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class RenameRegisteredModelResponse(betterproto.Message):
    registered_model: "RegisteredModel" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class UpdateRegisteredModel(betterproto.Message):
    # Registered model unique name identifier.
    name: str = betterproto.string_field(1)
    # If provided, updates the description for this ``registered_model``.
    description: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class UpdateRegisteredModelResponse(betterproto.Message):
    registered_model: "RegisteredModel" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class DeleteRegisteredModel(betterproto.Message):
    # Registered model unique name identifier.
    name: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class DeleteRegisteredModelResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class GetRegisteredModel(betterproto.Message):
    # Registered model unique name identifier.
    name: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class GetRegisteredModelResponse(betterproto.Message):
    registered_model: "RegisteredModel" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class ListRegisteredModels(betterproto.Message):
    # Maximum number of registered models desired. Max threshold is 1000.
    max_results: int = betterproto.int64_field(1)
    # Pagination token to go to the next page based on a previous query.
    page_token: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class ListRegisteredModelsResponse(betterproto.Message):
    registered_models: List["RegisteredModel"] = betterproto.message_field(1)
    # Pagination token to request next page of models for the same query.
    next_page_token: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class SearchRegisteredModels(betterproto.Message):
    # String filter condition, like "name LIKE 'my-model-name'". Interpreted in
    # the backend automatically as "name LIKE '%my-model-name%'". Single boolean
    # condition, with string values wrapped in single quotes.
    filter: str = betterproto.string_field(1)
    # Maximum number of models desired. Default is 100. Max threshold is 1000.
    max_results: int = betterproto.int64_field(2)
    # List of columns for ordering search results, which can include model name
    # and last updated timestamp with an optional "DESC" or "ASC" annotation,
    # where "ASC" is the default. Tiebreaks are done by model name ASC.
    order_by: List[str] = betterproto.string_field(3)
    # Pagination token to go to the next page based on a previous search query.
    page_token: str = betterproto.string_field(4)


@dataclass(eq=False, repr=False)
class SearchRegisteredModelsResponse(betterproto.Message):
    # Registered Models that match the search criteria.
    registered_models: List["RegisteredModel"] = betterproto.message_field(1)
    # Pagination token to request the next page of models.
    next_page_token: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class GetLatestVersions(betterproto.Message):
    # Registered model unique name identifier.
    name: str = betterproto.string_field(1)
    # List of stages.
    stages: List[str] = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class GetLatestVersionsResponse(betterproto.Message):
    # Latest version models for each requests stage. Only return models with
    # current ``READY`` status. If no ``stages`` provided, returns the latest
    # version for each stage, including ``"None"``.
    model_versions: List["ModelVersion"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class CreateModelVersion(betterproto.Message):
    # Register model under this name
    name: str = betterproto.string_field(1)
    # URI indicating the location of the model artifacts.
    source: str = betterproto.string_field(2)
    # MLflow run ID for correlation, if ``source`` was generated by an experiment
    # run in MLflow tracking server
    run_id: str = betterproto.string_field(3)
    # Additional metadata for model version.
    tags: List["ModelVersionTag"] = betterproto.message_field(4)
    # MLflow run link - this is the exact link of the run that generated this
    # model version, potentially hosted at another instance of MLflow.
    run_link: str = betterproto.string_field(5)
    # Optional description for model version.
    description: str = betterproto.string_field(6)


@dataclass(eq=False, repr=False)
class CreateModelVersionResponse(betterproto.Message):
    # Return new version number generated for this model in registry.
    model_version: "ModelVersion" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class UpdateModelVersion(betterproto.Message):
    # Name of the registered model
    name: str = betterproto.string_field(1)
    # Model version number
    version: str = betterproto.string_field(2)
    # If provided, updates the description for this ``registered_model``.
    description: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class UpdateModelVersionResponse(betterproto.Message):
    # Return new version number generated for this model in registry.
    model_version: "ModelVersion" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class TransitionModelVersionStage(betterproto.Message):
    # Name of the registered model
    name: str = betterproto.string_field(1)
    # Model version number
    version: str = betterproto.string_field(2)
    # Transition `model_version` to new stage.
    stage: str = betterproto.string_field(3)
    # When transitioning a model version to a particular stage, this flag
    # dictates whether all existing model versions in that stage should be
    # atomically moved to the "archived" stage. This ensures that at-most-one
    # model version exists in the target stage. This field is *required* when
    # transitioning a model versions's stage
    archive_existing_versions: bool = betterproto.bool_field(4)


@dataclass(eq=False, repr=False)
class TransitionModelVersionStageResponse(betterproto.Message):
    # Updated model version
    model_version: "ModelVersion" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class DeleteModelVersion(betterproto.Message):
    # Name of the registered model
    name: str = betterproto.string_field(1)
    # Model version number
    version: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class DeleteModelVersionResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class GetModelVersion(betterproto.Message):
    # Name of the registered model
    name: str = betterproto.string_field(1)
    # Model version number
    version: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class GetModelVersionResponse(betterproto.Message):
    model_version: "ModelVersion" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class SearchModelVersions(betterproto.Message):
    # String filter condition, like "name='my-model-name'". Must be a single
    # boolean condition, with string values wrapped in single quotes.
    filter: str = betterproto.string_field(1)
    # Maximum number of models desired. Max threshold is 200K.
    max_results: int = betterproto.int64_field(2)
    # List of columns to be ordered by including model name, version, stage with
    # an optional "DESC" or "ASC" annotation, where "ASC" is the default.
    # Tiebreaks are done by latest stage transition timestamp, followed by name
    # ASC, followed by version DESC.
    order_by: List[str] = betterproto.string_field(3)
    # Pagination token to go to next page based on previous search query.
    page_token: str = betterproto.string_field(4)


@dataclass(eq=False, repr=False)
class SearchModelVersionsResponse(betterproto.Message):
    # Models that match the search criteria
    model_versions: List["ModelVersion"] = betterproto.message_field(1)
    # Pagination token to request next page of models for the same search query.
    next_page_token: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class GetModelVersionDownloadUri(betterproto.Message):
    # Name of the registered model
    name: str = betterproto.string_field(1)
    # Model version number
    version: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class GetModelVersionDownloadUriResponse(betterproto.Message):
    # URI corresponding to where artifacts for this model version are stored.
    artifact_uri: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class ModelVersionTag(betterproto.Message):
    """Tag for a model version."""

    # The tag key.
    key: str = betterproto.string_field(1)
    # The tag value.
    value: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class RegisteredModelTag(betterproto.Message):
    """Tag for a registered model"""

    # The tag key.
    key: str = betterproto.string_field(1)
    # The tag value.
    value: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class SetRegisteredModelTag(betterproto.Message):
    # Unique name of the model.
    name: str = betterproto.string_field(1)
    # Name of the tag. Maximum size depends on storage backend. If a tag with
    # this name already exists, its preexisting value will be replaced by the
    # specified `value`. All storage backends are guaranteed to support key
    # values up to 250 bytes in size.
    key: str = betterproto.string_field(2)
    # String value of the tag being logged. Maximum size depends on storage
    # backend. All storage backends are guaranteed to support key values up to
    # 5000 bytes in size.
    value: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class SetRegisteredModelTagResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class SetModelVersionTag(betterproto.Message):
    # Unique name of the model.
    name: str = betterproto.string_field(1)
    # Model version number.
    version: str = betterproto.string_field(2)
    # Name of the tag. Maximum size depends on storage backend. If a tag with
    # this name already exists, its preexisting value will be replaced by the
    # specified `value`. All storage backends are guaranteed to support key
    # values up to 250 bytes in size.
    key: str = betterproto.string_field(3)
    # String value of the tag being logged. Maximum size depends on storage
    # backend. All storage backends are guaranteed to support key values up to
    # 5000 bytes in size.
    value: str = betterproto.string_field(4)


@dataclass(eq=False, repr=False)
class SetModelVersionTagResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class DeleteRegisteredModelTag(betterproto.Message):
    # Name of the registered model that the tag was logged under.
    name: str = betterproto.string_field(1)
    # Name of the tag. The name must be an exact match; wild-card deletion is not
    # supported. Maximum size is 250 bytes.
    key: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class DeleteRegisteredModelTagResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class DeleteModelVersionTag(betterproto.Message):
    # Name of the registered model that the tag was logged under.
    name: str = betterproto.string_field(1)
    # Model version number that the tag was logged under.
    version: str = betterproto.string_field(2)
    # Name of the tag. The name must be an exact match; wild-card deletion is not
    # supported. Maximum size is 250 bytes.
    key: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class DeleteModelVersionTagResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class Metric(betterproto.Message):
    """Metric associated with a run, represented as a key-value pair."""

    # Key identifying this metric.
    key: str = betterproto.string_field(1)
    # Value associated with this metric.
    value: float = betterproto.double_field(2)
    # The timestamp at which this metric was recorded.
    timestamp: int = betterproto.int64_field(3)
    # Step at which to log the metric.
    step: int = betterproto.int64_field(4)


@dataclass(eq=False, repr=False)
class Param(betterproto.Message):
    """Param associated with a run."""

    # Key identifying this param.
    key: str = betterproto.string_field(1)
    # Value associated with this param.
    value: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class Run(betterproto.Message):
    """A single run."""

    # Run metadata.
    info: "RunInfo" = betterproto.message_field(1)
    # Run data.
    data: "RunData" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class RunData(betterproto.Message):
    """Run data (metrics, params, and tags)."""

    # Run metrics.
    metrics: List["Metric"] = betterproto.message_field(1)
    # Run parameters.
    params: List["Param"] = betterproto.message_field(2)
    # Additional metadata key-value pairs.
    tags: List["RunTag"] = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class RunTag(betterproto.Message):
    """Tag for a run."""

    # The tag key.
    key: str = betterproto.string_field(1)
    # The tag value.
    value: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class ExperimentTag(betterproto.Message):
    """Tag for an experiment."""

    # The tag key.
    key: str = betterproto.string_field(1)
    # The tag value.
    value: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class RunInfo(betterproto.Message):
    """Metadata of a single run."""

    # Unique identifier for the run.
    run_id: str = betterproto.string_field(15)
    # [Deprecated, use run_id instead] Unique identifier for the run. This field
    # will be removed in a future MLflow version.
    run_uuid: str = betterproto.string_field(1)
    # The experiment ID.
    experiment_id: str = betterproto.string_field(2)
    # User who initiated the run. This field is deprecated as of MLflow 1.0, and
    # will be removed in a future MLflow release. Use 'mlflow.user' tag instead.
    user_id: str = betterproto.string_field(6)
    # Current status of the run.
    status: "RunStatus" = betterproto.enum_field(7)
    # Unix timestamp of when the run started in milliseconds.
    start_time: int = betterproto.int64_field(8)
    # Unix timestamp of when the run ended in milliseconds.
    end_time: int = betterproto.int64_field(9)
    # URI of the directory where artifacts should be uploaded. This can be a
    # local path (starting with "/"), or a distributed file system (DFS) path,
    # like ``s3://bucket/directory`` or ``dbfs:/my/directory``. If not set, the
    # local ``./mlruns`` directory is  chosen.
    artifact_uri: str = betterproto.string_field(13)
    # Current life cycle stage of the experiment : OneOf("active", "deleted")
    lifecycle_stage: str = betterproto.string_field(14)


@dataclass(eq=False, repr=False)
class Experiment(betterproto.Message):
    """Experiment"""

    # Unique identifier for the experiment.
    experiment_id: str = betterproto.string_field(1)
    # Human readable name that identifies the experiment.
    name: str = betterproto.string_field(2)
    # Location where artifacts for the experiment are stored.
    artifact_location: str = betterproto.string_field(3)
    # Current life cycle stage of the experiment: "active" or "deleted". Deleted
    # experiments are not returned by APIs.
    lifecycle_stage: str = betterproto.string_field(4)
    # Last update time
    last_update_time: int = betterproto.int64_field(5)
    # Creation time
    creation_time: int = betterproto.int64_field(6)
    # Tags: Additional metadata key-value pairs.
    tags: List["ExperimentTag"] = betterproto.message_field(7)


@dataclass(eq=False, repr=False)
class CreateExperiment(betterproto.Message):
    # Experiment name.
    name: str = betterproto.string_field(1)
    # Location where all artifacts for the experiment are stored. If not
    # provided, the remote server will select an appropriate default.
    artifact_location: str = betterproto.string_field(2)
    # A collection of tags to set on the experiment. Maximum tag size and number
    # of tags per request depends on the storage backend. All storage backends
    # are guaranteed to support tag keys up to 250 bytes in size and tag values
    # up to 5000 bytes in size. All storage backends are also guaranteed to
    # support up to 20 tags per request.
    tags: List["ExperimentTag"] = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class CreateExperimentResponse(betterproto.Message):
    # Unique identifier for the experiment.
    experiment_id: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class ListExperiments(betterproto.Message):
    # Qualifier for type of experiments to be returned. If unspecified, return
    # only active experiments.
    view_type: "ViewType" = betterproto.enum_field(1)
    # Maximum number of experiments desired. Servers may select a desired default
    # `max_results` value. All servers are guaranteed to support a `max_results`
    # threshold of at least 1,000 but may support more. Callers of this endpoint
    # are encouraged to pass max_results explicitly and leverage page_token to
    # iterate through experiments.
    max_results: int = betterproto.int64_field(2)
    # Pagination token to go to the next page based on a previous query.
    page_token: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class ListExperimentsResponse(betterproto.Message):
    # All experiments.
    experiments: List["Experiment"] = betterproto.message_field(1)
    # Pagination token to request next page of experiments for the same query.
    next_page_token: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class GetExperiment(betterproto.Message):
    # ID of the associated experiment.
    experiment_id: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class GetExperimentResponse(betterproto.Message):
    # Experiment details.
    experiment: "Experiment" = betterproto.message_field(1)
    # A collection of active runs in the experiment. Note: this may not contain
    # all of the experiment's active runs. This field is deprecated. Please use
    # the "Search Runs" API to fetch runs within an experiment.
    runs: List["RunInfo"] = betterproto.message_field(2)

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.runs:
            warnings.warn("GetExperimentResponse.runs is deprecated", DeprecationWarning)


@dataclass(eq=False, repr=False)
class DeleteExperiment(betterproto.Message):
    # ID of the associated experiment.
    experiment_id: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class DeleteExperimentResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class RestoreExperiment(betterproto.Message):
    # ID of the associated experiment.
    experiment_id: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class RestoreExperimentResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class UpdateExperiment(betterproto.Message):
    # ID of the associated experiment.
    experiment_id: str = betterproto.string_field(1)
    # If provided, the experiment's name is changed to the new name. The new name
    # must be unique.
    new_name: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class UpdateExperimentResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class CreateRun(betterproto.Message):
    # ID of the associated experiment.
    experiment_id: str = betterproto.string_field(1)
    # ID of the user executing the run. This field is deprecated as of MLflow
    # 1.0, and will be removed in a future MLflow release. Use 'mlflow.user' tag
    # instead.
    user_id: str = betterproto.string_field(2)
    # Unix timestamp in milliseconds of when the run started.
    start_time: int = betterproto.int64_field(7)
    # Additional metadata for run.
    tags: List["RunTag"] = betterproto.message_field(9)


@dataclass(eq=False, repr=False)
class CreateRunResponse(betterproto.Message):
    # The newly created run.
    run: "Run" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class UpdateRun(betterproto.Message):
    # ID of the run to update. Must be provided.
    run_id: str = betterproto.string_field(4)
    # [Deprecated, use run_id instead] ID of the run to update.. This field will
    # be removed in a future MLflow version.
    run_uuid: str = betterproto.string_field(1)
    # Updated status of the run.
    status: "RunStatus" = betterproto.enum_field(2)
    # Unix timestamp in milliseconds of when the run ended.
    end_time: int = betterproto.int64_field(3)


@dataclass(eq=False, repr=False)
class UpdateRunResponse(betterproto.Message):
    # Updated metadata of the run.
    run_info: "RunInfo" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class DeleteRun(betterproto.Message):
    # ID of the run to delete.
    run_id: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class DeleteRunResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class RestoreRun(betterproto.Message):
    # ID of the run to restore.
    run_id: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class RestoreRunResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class LogMetric(betterproto.Message):
    # ID of the run under which to log the metric. Must be provided.
    run_id: str = betterproto.string_field(6)
    # [Deprecated, use run_id instead] ID of the run under which to log the
    # metric. This field will be removed in a future MLflow version.
    run_uuid: str = betterproto.string_field(1)
    # Name of the metric.
    key: str = betterproto.string_field(2)
    # Double value of the metric being logged.
    value: float = betterproto.double_field(3)
    # Unix timestamp in milliseconds at the time metric was logged.
    timestamp: int = betterproto.int64_field(4)
    # Step at which to log the metric
    step: int = betterproto.int64_field(5)


@dataclass(eq=False, repr=False)
class LogMetricResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class LogParam(betterproto.Message):
    # ID of the run under which to log the param. Must be provided.
    run_id: str = betterproto.string_field(4)
    # [Deprecated, use run_id instead] ID of the run under which to log the
    # param. This field will be removed in a future MLflow version.
    run_uuid: str = betterproto.string_field(1)
    # Name of the param. Maximum size is 255 bytes.
    key: str = betterproto.string_field(2)
    # String value of the param being logged. Maximum size is 500 bytes.
    value: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class LogParamResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class SetExperimentTag(betterproto.Message):
    # ID of the experiment under which to log the tag. Must be provided.
    experiment_id: str = betterproto.string_field(1)
    # Name of the tag. Maximum size depends on storage backend. All storage
    # backends are guaranteed to support key values up to 250 bytes in size.
    key: str = betterproto.string_field(2)
    # String value of the tag being logged. Maximum size depends on storage
    # backend. All storage backends are guaranteed to support key values up to
    # 5000 bytes in size.
    value: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class SetExperimentTagResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class SetTag(betterproto.Message):
    # ID of the run under which to log the tag. Must be provided.
    run_id: str = betterproto.string_field(4)
    # [Deprecated, use run_id instead] ID of the run under which to log the tag.
    # This field will be removed in a future MLflow version.
    run_uuid: str = betterproto.string_field(1)
    # Name of the tag. Maximum size depends on storage backend. All storage
    # backends are guaranteed to support key values up to 250 bytes in size.
    key: str = betterproto.string_field(2)
    # String value of the tag being logged. Maximum size depends on storage
    # backend. All storage backends are guaranteed to support key values up to
    # 5000 bytes in size.
    value: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class SetTagResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class DeleteTag(betterproto.Message):
    # ID of the run that the tag was logged under. Must be provided.
    run_id: str = betterproto.string_field(1)
    # Name of the tag. Maximum size is 255 bytes. Must be provided.
    key: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class DeleteTagResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class GetRun(betterproto.Message):
    # ID of the run to fetch. Must be provided.
    run_id: str = betterproto.string_field(2)
    # [Deprecated, use run_id instead] ID of the run to fetch. This field will be
    # removed in a future MLflow version.
    run_uuid: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class GetRunResponse(betterproto.Message):
    # Run metadata (name, start time, etc) and data (metrics, params, and tags).
    run: "Run" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class SearchRuns(betterproto.Message):
    # List of experiment IDs to search over.
    experiment_ids: List[str] = betterproto.string_field(1)
    # A filter expression over params, metrics, and tags, that allows returning a
    # subset of runs. The syntax is a subset of SQL that supports ANDing together
    # binary operations between a param, metric, or tag and a constant. Example:
    # ``metrics.rmse < 1 and params.model_class = 'LogisticRegression'`` You can
    # select columns with special characters (hyphen, space, period, etc.) by
    # using double quotes: ``metrics."model class" = 'LinearRegression' and
    # tags."user-name" = 'Tomas'`` Supported operators are ``=``, ``!=``, ``>``,
    # ``>=``, ``<``, and ``<=``.
    filter: str = betterproto.string_field(4)
    # Whether to display only active, only deleted, or all runs. Defaults to only
    # active runs.
    run_view_type: "ViewType" = betterproto.enum_field(3)
    # Maximum number of runs desired. If unspecified, defaults to 1000. All
    # servers are guaranteed to support a `max_results` threshold of at least
    # 50,000 but may support more. Callers of this endpoint are encouraged to
    # pass max_results explicitly and leverage page_token to iterate through
    # experiments.
    max_results: int = betterproto.int32_field(5)
    # List of columns to be ordered by, including attributes, params, metrics,
    # and tags with an optional "DESC" or "ASC" annotation, where "ASC" is the
    # default. Example: ["params.input DESC", "metrics.alpha ASC",
    # "metrics.rmse"] Tiebreaks are done by start_time DESC followed by run_id
    # for runs with the same start time (and this is the default ordering
    # criterion if order_by is not provided).
    order_by: List[str] = betterproto.string_field(6)
    page_token: str = betterproto.string_field(7)


@dataclass(eq=False, repr=False)
class SearchRunsResponse(betterproto.Message):
    # Runs that match the search criteria.
    runs: List["Run"] = betterproto.message_field(1)
    next_page_token: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class ListArtifacts(betterproto.Message):
    # ID of the run whose artifacts to list. Must be provided.
    run_id: str = betterproto.string_field(3)
    # [Deprecated, use run_id instead] ID of the run whose artifacts to list.
    # This field will be removed in a future MLflow version.
    run_uuid: str = betterproto.string_field(1)
    # Filter artifacts matching this path (a relative path from the root artifact
    # directory).
    path: str = betterproto.string_field(2)
    # Token indicating the page of artifact results to fetch
    page_token: str = betterproto.string_field(4)


@dataclass(eq=False, repr=False)
class ListArtifactsResponse(betterproto.Message):
    # Root artifact directory for the run.
    root_uri: str = betterproto.string_field(1)
    # File location and metadata for artifacts.
    files: List["FileInfo"] = betterproto.message_field(2)
    # Token that can be used to retrieve the next page of artifact results
    next_page_token: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class FileInfo(betterproto.Message):
    """Metadata of a single artifact file or directory."""

    # Path relative to the root artifact directory run.
    path: str = betterproto.string_field(1)
    # Whether the path is a directory.
    is_dir: bool = betterproto.bool_field(2)
    # Size in bytes. Unset for directories.
    file_size: int = betterproto.int64_field(3)


@dataclass(eq=False, repr=False)
class GetMetricHistory(betterproto.Message):
    # ID of the run from which to fetch metric values. Must be provided.
    run_id: str = betterproto.string_field(3)
    # [Deprecated, use run_id instead] ID of the run from which to fetch metric
    # values. This field will be removed in a future MLflow version.
    run_uuid: str = betterproto.string_field(1)
    # Name of the metric.
    metric_key: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class GetMetricHistoryResponse(betterproto.Message):
    # All logged values for this metric.
    metrics: List["Metric"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class LogBatch(betterproto.Message):
    # ID of the run to log under
    run_id: str = betterproto.string_field(1)
    # Metrics to log. A single request can contain up to 1000 metrics, and up to
    # 1000 metrics, params, and tags in total.
    metrics: List["Metric"] = betterproto.message_field(2)
    # Params to log. A single request can contain up to 100 params, and up to
    # 1000 metrics, params, and tags in total.
    params: List["Param"] = betterproto.message_field(3)
    # Tags to log. A single request can contain up to 100 tags, and up to 1000
    # metrics, params, and tags in total.
    tags: List["RunTag"] = betterproto.message_field(4)


@dataclass(eq=False, repr=False)
class LogBatchResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class LogModel(betterproto.Message):
    # ID of the run to log under
    run_id: str = betterproto.string_field(1)
    # MLmodel file in json format.
    model_json: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class LogModelResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class GetExperimentByName(betterproto.Message):
    # Name of the associated experiment.
    experiment_name: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class GetExperimentByNameResponse(betterproto.Message):
    # Experiment details.
    experiment: "Experiment" = betterproto.message_field(1)


class DatabricksMlflowArtifactsServiceStub(betterproto.ServiceStub):
    async def get_credentials_for_read(
        self, *, run_id: str = "", path: Optional[List[str]] = None, page_token: str = ""
    ) -> "GetCredentialsForReadResponse":
        path = path or []

        request = GetCredentialsForRead()
        request.run_id = run_id
        request.path = path
        request.page_token = page_token

        return await self._unary_unary(
            "/mlflow.DatabricksMlflowArtifactsService/getCredentialsForRead",
            request,
            GetCredentialsForReadResponse,
        )

    async def get_credentials_for_write(
        self, *, run_id: str = "", path: Optional[List[str]] = None, page_token: str = ""
    ) -> "GetCredentialsForWriteResponse":
        path = path or []

        request = GetCredentialsForWrite()
        request.run_id = run_id
        request.path = path
        request.page_token = page_token

        return await self._unary_unary(
            "/mlflow.DatabricksMlflowArtifactsService/getCredentialsForWrite",
            request,
            GetCredentialsForWriteResponse,
        )


class ModelRegistryServiceStub(betterproto.ServiceStub):
    async def create_registered_model(
        self,
        *,
        name: str = "",
        tags: Optional[List["RegisteredModelTag"]] = None,
        description: str = ""
    ) -> "CreateRegisteredModelResponse":
        tags = tags or []

        request = CreateRegisteredModel()
        request.name = name
        if tags is not None:
            request.tags = tags
        request.description = description

        return await self._unary_unary(
            "/mlflow.ModelRegistryService/createRegisteredModel",
            request,
            CreateRegisteredModelResponse,
        )

    async def rename_registered_model(
        self, *, name: str = "", new_name: str = ""
    ) -> "RenameRegisteredModelResponse":

        request = RenameRegisteredModel()
        request.name = name
        request.new_name = new_name

        return await self._unary_unary(
            "/mlflow.ModelRegistryService/renameRegisteredModel",
            request,
            RenameRegisteredModelResponse,
        )

    async def update_registered_model(
        self, *, name: str = "", description: str = ""
    ) -> "UpdateRegisteredModelResponse":

        request = UpdateRegisteredModel()
        request.name = name
        request.description = description

        return await self._unary_unary(
            "/mlflow.ModelRegistryService/updateRegisteredModel",
            request,
            UpdateRegisteredModelResponse,
        )

    async def delete_registered_model(self, *, name: str = "") -> "DeleteRegisteredModelResponse":

        request = DeleteRegisteredModel()
        request.name = name

        return await self._unary_unary(
            "/mlflow.ModelRegistryService/deleteRegisteredModel",
            request,
            DeleteRegisteredModelResponse,
        )

    async def get_registered_model(self, *, name: str = "") -> "GetRegisteredModelResponse":

        request = GetRegisteredModel()
        request.name = name

        return await self._unary_unary(
            "/mlflow.ModelRegistryService/getRegisteredModel",
            request,
            GetRegisteredModelResponse,
        )

    async def search_registered_models(
        self,
        *,
        filter: str = "",
        max_results: int = 0,
        order_by: Optional[List[str]] = None,
        page_token: str = ""
    ) -> "SearchRegisteredModelsResponse":
        order_by = order_by or []

        request = SearchRegisteredModels()
        request.filter = filter
        request.max_results = max_results
        request.order_by = order_by
        request.page_token = page_token

        return await self._unary_unary(
            "/mlflow.ModelRegistryService/searchRegisteredModels",
            request,
            SearchRegisteredModelsResponse,
        )

    async def list_registered_models(
        self, *, max_results: int = 0, page_token: str = ""
    ) -> "ListRegisteredModelsResponse":

        request = ListRegisteredModels()
        request.max_results = max_results
        request.page_token = page_token

        return await self._unary_unary(
            "/mlflow.ModelRegistryService/listRegisteredModels",
            request,
            ListRegisteredModelsResponse,
        )

    async def get_latest_versions(
        self, *, name: str = "", stages: Optional[List[str]] = None
    ) -> "GetLatestVersionsResponse":
        stages = stages or []

        request = GetLatestVersions()
        request.name = name
        request.stages = stages

        return await self._unary_unary(
            "/mlflow.ModelRegistryService/getLatestVersions",
            request,
            GetLatestVersionsResponse,
        )

    async def create_model_version(
        self,
        *,
        name: str = "",
        source: str = "",
        run_id: str = "",
        tags: Optional[List["ModelVersionTag"]] = None,
        run_link: str = "",
        description: str = ""
    ) -> "CreateModelVersionResponse":
        tags = tags or []

        request = CreateModelVersion()
        request.name = name
        request.source = source
        request.run_id = run_id
        if tags is not None:
            request.tags = tags
        request.run_link = run_link
        request.description = description

        return await self._unary_unary(
            "/mlflow.ModelRegistryService/createModelVersion",
            request,
            CreateModelVersionResponse,
        )

    async def update_model_version(
        self, *, name: str = "", version: str = "", description: str = ""
    ) -> "UpdateModelVersionResponse":

        request = UpdateModelVersion()
        request.name = name
        request.version = version
        request.description = description

        return await self._unary_unary(
            "/mlflow.ModelRegistryService/updateModelVersion",
            request,
            UpdateModelVersionResponse,
        )

    async def transition_model_version_stage(
        self,
        *,
        name: str = "",
        version: str = "",
        stage: str = "",
        archive_existing_versions: bool = False
    ) -> "TransitionModelVersionStageResponse":

        request = TransitionModelVersionStage()
        request.name = name
        request.version = version
        request.stage = stage
        request.archive_existing_versions = archive_existing_versions

        return await self._unary_unary(
            "/mlflow.ModelRegistryService/transitionModelVersionStage",
            request,
            TransitionModelVersionStageResponse,
        )

    async def delete_model_version(
        self, *, name: str = "", version: str = ""
    ) -> "DeleteModelVersionResponse":

        request = DeleteModelVersion()
        request.name = name
        request.version = version

        return await self._unary_unary(
            "/mlflow.ModelRegistryService/deleteModelVersion",
            request,
            DeleteModelVersionResponse,
        )

    async def get_model_version(
        self, *, name: str = "", version: str = ""
    ) -> "GetModelVersionResponse":

        request = GetModelVersion()
        request.name = name
        request.version = version

        return await self._unary_unary(
            "/mlflow.ModelRegistryService/getModelVersion",
            request,
            GetModelVersionResponse,
        )

    async def search_model_versions(
        self,
        *,
        filter: str = "",
        max_results: int = 0,
        order_by: Optional[List[str]] = None,
        page_token: str = ""
    ) -> "SearchModelVersionsResponse":
        order_by = order_by or []

        request = SearchModelVersions()
        request.filter = filter
        request.max_results = max_results
        request.order_by = order_by
        request.page_token = page_token

        return await self._unary_unary(
            "/mlflow.ModelRegistryService/searchModelVersions",
            request,
            SearchModelVersionsResponse,
        )

    async def get_model_version_download_uri(
        self, *, name: str = "", version: str = ""
    ) -> "GetModelVersionDownloadUriResponse":

        request = GetModelVersionDownloadUri()
        request.name = name
        request.version = version

        return await self._unary_unary(
            "/mlflow.ModelRegistryService/getModelVersionDownloadUri",
            request,
            GetModelVersionDownloadUriResponse,
        )

    async def set_registered_model_tag(
        self, *, name: str = "", key: str = "", value: str = ""
    ) -> "SetRegisteredModelTagResponse":

        request = SetRegisteredModelTag()
        request.name = name
        request.key = key
        request.value = value

        return await self._unary_unary(
            "/mlflow.ModelRegistryService/setRegisteredModelTag",
            request,
            SetRegisteredModelTagResponse,
        )

    async def set_model_version_tag(
        self, *, name: str = "", version: str = "", key: str = "", value: str = ""
    ) -> "SetModelVersionTagResponse":

        request = SetModelVersionTag()
        request.name = name
        request.version = version
        request.key = key
        request.value = value

        return await self._unary_unary(
            "/mlflow.ModelRegistryService/setModelVersionTag",
            request,
            SetModelVersionTagResponse,
        )

    async def delete_registered_model_tag(
        self, *, name: str = "", key: str = ""
    ) -> "DeleteRegisteredModelTagResponse":

        request = DeleteRegisteredModelTag()
        request.name = name
        request.key = key

        return await self._unary_unary(
            "/mlflow.ModelRegistryService/deleteRegisteredModelTag",
            request,
            DeleteRegisteredModelTagResponse,
        )

    async def delete_model_version_tag(
        self, *, name: str = "", version: str = "", key: str = ""
    ) -> "DeleteModelVersionTagResponse":

        request = DeleteModelVersionTag()
        request.name = name
        request.version = version
        request.key = key

        return await self._unary_unary(
            "/mlflow.ModelRegistryService/deleteModelVersionTag",
            request,
            DeleteModelVersionTagResponse,
        )


class MlflowServiceStub(betterproto.ServiceStub):
    async def get_experiment_by_name(
        self, *, experiment_name: str = ""
    ) -> "GetExperimentByNameResponse":

        request = GetExperimentByName()
        request.experiment_name = experiment_name

        return await self._unary_unary(
            "/mlflow.MlflowService/getExperimentByName",
            request,
            GetExperimentByNameResponse,
        )

    async def create_experiment(
        self,
        *,
        name: str = "",
        artifact_location: str = "",
        tags: Optional[List["ExperimentTag"]] = None
    ) -> "CreateExperimentResponse":
        tags = tags or []

        request = CreateExperiment()
        request.name = name
        request.artifact_location = artifact_location
        if tags is not None:
            request.tags = tags

        return await self._unary_unary(
            "/mlflow.MlflowService/createExperiment", request, CreateExperimentResponse
        )

    async def list_experiments(
        self, *, view_type: "ViewType" = 1, max_results: int = 0, page_token: str = ""
    ) -> "ListExperimentsResponse":

        request = ListExperiments()
        request.view_type = view_type
        request.max_results = max_results
        request.page_token = page_token

        return await self._unary_unary(
            "/mlflow.MlflowService/listExperiments", request, ListExperimentsResponse
        )

    async def get_experiment(self, *, experiment_id: str = "") -> "GetExperimentResponse":

        request = GetExperiment()
        request.experiment_id = experiment_id

        return await self._unary_unary(
            "/mlflow.MlflowService/getExperiment", request, GetExperimentResponse
        )

    async def delete_experiment(self, *, experiment_id: str = "") -> "DeleteExperimentResponse":

        request = DeleteExperiment()
        request.experiment_id = experiment_id

        return await self._unary_unary(
            "/mlflow.MlflowService/deleteExperiment", request, DeleteExperimentResponse
        )

    async def restore_experiment(self, *, experiment_id: str = "") -> "RestoreExperimentResponse":

        request = RestoreExperiment()
        request.experiment_id = experiment_id

        return await self._unary_unary(
            "/mlflow.MlflowService/restoreExperiment",
            request,
            RestoreExperimentResponse,
        )

    async def update_experiment(
        self, *, experiment_id: str = "", new_name: str = ""
    ) -> "UpdateExperimentResponse":

        request = UpdateExperiment()
        request.experiment_id = experiment_id
        request.new_name = new_name

        return await self._unary_unary(
            "/mlflow.MlflowService/updateExperiment", request, UpdateExperimentResponse
        )

    async def create_run(
        self,
        *,
        experiment_id: str = "",
        user_id: str = "",
        start_time: int = 0,
        tags: Optional[List["RunTag"]] = None
    ) -> "CreateRunResponse":
        tags = tags or []

        request = CreateRun()
        request.experiment_id = experiment_id
        request.user_id = user_id
        request.start_time = start_time
        if tags is not None:
            request.tags = tags

        return await self._unary_unary(
            "/mlflow.MlflowService/createRun", request, CreateRunResponse
        )

    async def update_run(
        self, *, run_id: str = "", run_uuid: str = "", status: "RunStatus" = 1, end_time: int = 0
    ) -> "UpdateRunResponse":

        request = UpdateRun()
        request.run_id = run_id
        request.run_uuid = run_uuid
        request.status = status
        request.end_time = end_time

        return await self._unary_unary(
            "/mlflow.MlflowService/updateRun", request, UpdateRunResponse
        )

    async def delete_run(self, *, run_id: str = "") -> "DeleteRunResponse":

        request = DeleteRun()
        request.run_id = run_id

        return await self._unary_unary(
            "/mlflow.MlflowService/deleteRun", request, DeleteRunResponse
        )

    async def restore_run(self, *, run_id: str = "") -> "RestoreRunResponse":

        request = RestoreRun()
        request.run_id = run_id

        return await self._unary_unary(
            "/mlflow.MlflowService/restoreRun", request, RestoreRunResponse
        )

    async def log_metric(
        self,
        *,
        run_id: str = "",
        run_uuid: str = "",
        key: str = "",
        value: float = 0.0,
        timestamp: int = 0,
        step: int = 0
    ) -> "LogMetricResponse":

        request = LogMetric()
        request.run_id = run_id
        request.run_uuid = run_uuid
        request.key = key
        request.value = value
        request.timestamp = timestamp
        request.step = step

        return await self._unary_unary(
            "/mlflow.MlflowService/logMetric", request, LogMetricResponse
        )

    async def log_param(
        self, *, run_id: str = "", run_uuid: str = "", key: str = "", value: str = ""
    ) -> "LogParamResponse":

        request = LogParam()
        request.run_id = run_id
        request.run_uuid = run_uuid
        request.key = key
        request.value = value

        return await self._unary_unary("/mlflow.MlflowService/logParam", request, LogParamResponse)

    async def set_experiment_tag(
        self, *, experiment_id: str = "", key: str = "", value: str = ""
    ) -> "SetExperimentTagResponse":

        request = SetExperimentTag()
        request.experiment_id = experiment_id
        request.key = key
        request.value = value

        return await self._unary_unary(
            "/mlflow.MlflowService/setExperimentTag", request, SetExperimentTagResponse
        )

    async def set_tag(
        self, *, run_id: str = "", run_uuid: str = "", key: str = "", value: str = ""
    ) -> "SetTagResponse":

        request = SetTag()
        request.run_id = run_id
        request.run_uuid = run_uuid
        request.key = key
        request.value = value

        return await self._unary_unary("/mlflow.MlflowService/setTag", request, SetTagResponse)

    async def delete_tag(self, *, run_id: str = "", key: str = "") -> "DeleteTagResponse":

        request = DeleteTag()
        request.run_id = run_id
        request.key = key

        return await self._unary_unary(
            "/mlflow.MlflowService/deleteTag", request, DeleteTagResponse
        )

    async def get_run(self, *, run_id: str = "", run_uuid: str = "") -> "GetRunResponse":

        request = GetRun()
        request.run_id = run_id
        request.run_uuid = run_uuid

        return await self._unary_unary("/mlflow.MlflowService/getRun", request, GetRunResponse)

    async def search_runs(
        self,
        *,
        experiment_ids: Optional[List[str]] = None,
        filter: str = "",
        run_view_type: "ViewType" = 1,
        max_results: int = 0,
        order_by: Optional[List[str]] = None,
        page_token: str = ""
    ) -> "SearchRunsResponse":
        experiment_ids = experiment_ids or []
        order_by = order_by or []

        request = SearchRuns()
        request.experiment_ids = experiment_ids
        request.filter = filter
        request.run_view_type = run_view_type
        request.max_results = max_results
        request.order_by = order_by
        request.page_token = page_token

        return await self._unary_unary(
            "/mlflow.MlflowService/searchRuns", request, SearchRunsResponse
        )

    async def list_artifacts(
        self, *, run_id: str = "", run_uuid: str = "", path: str = "", page_token: str = ""
    ) -> "ListArtifactsResponse":

        request = ListArtifacts()
        request.run_id = run_id
        request.run_uuid = run_uuid
        request.path = path
        request.page_token = page_token

        return await self._unary_unary(
            "/mlflow.MlflowService/listArtifacts", request, ListArtifactsResponse
        )

    async def get_metric_history(
        self, *, run_id: str = "", run_uuid: str = "", metric_key: str = ""
    ) -> "GetMetricHistoryResponse":

        request = GetMetricHistory()
        request.run_id = run_id
        request.run_uuid = run_uuid
        request.metric_key = metric_key

        return await self._unary_unary(
            "/mlflow.MlflowService/getMetricHistory", request, GetMetricHistoryResponse
        )

    async def log_batch(
        self,
        *,
        run_id: str = "",
        metrics: Optional[List["Metric"]] = None,
        params: Optional[List["Param"]] = None,
        tags: Optional[List["RunTag"]] = None
    ) -> "LogBatchResponse":
        metrics = metrics or []
        params = params or []
        tags = tags or []

        request = LogBatch()
        request.run_id = run_id
        if metrics is not None:
            request.metrics = metrics
        if params is not None:
            request.params = params
        if tags is not None:
            request.tags = tags

        return await self._unary_unary("/mlflow.MlflowService/logBatch", request, LogBatchResponse)

    async def log_model(self, *, run_id: str = "", model_json: str = "") -> "LogModelResponse":

        request = LogModel()
        request.run_id = run_id
        request.model_json = model_json

        return await self._unary_unary("/mlflow.MlflowService/logModel", request, LogModelResponse)


class DatabricksMlflowArtifactsServiceBase(ServiceBase):
    async def get_credentials_for_read(
        self, run_id: str, path: Optional[List[str]], page_token: str
    ) -> "GetCredentialsForReadResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_credentials_for_write(
        self, run_id: str, path: Optional[List[str]], page_token: str
    ) -> "GetCredentialsForWriteResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_credentials_for_read(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "run_id": request.run_id,
            "path": request.path,
            "page_token": request.page_token,
        }

        response = await self.get_credentials_for_read(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_get_credentials_for_write(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "run_id": request.run_id,
            "path": request.path,
            "page_token": request.page_token,
        }

        response = await self.get_credentials_for_write(**request_kwargs)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/mlflow.DatabricksMlflowArtifactsService/getCredentialsForRead": grpclib.const.Handler(
                self.__rpc_get_credentials_for_read,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetCredentialsForRead,
                GetCredentialsForReadResponse,
            ),
            "/mlflow.DatabricksMlflowArtifactsService/getCredentialsForWrite": grpclib.const.Handler(
                self.__rpc_get_credentials_for_write,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetCredentialsForWrite,
                GetCredentialsForWriteResponse,
            ),
        }


class ModelRegistryServiceBase(ServiceBase):
    async def create_registered_model(
        self, name: str, tags: Optional[List["RegisteredModelTag"]], description: str
    ) -> "CreateRegisteredModelResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def rename_registered_model(
        self, name: str, new_name: str
    ) -> "RenameRegisteredModelResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def update_registered_model(
        self, name: str, description: str
    ) -> "UpdateRegisteredModelResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_registered_model(self, name: str) -> "DeleteRegisteredModelResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_registered_model(self, name: str) -> "GetRegisteredModelResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def search_registered_models(
        self,
        filter: str,
        max_results: int,
        order_by: Optional[List[str]],
        page_token: str,
    ) -> "SearchRegisteredModelsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def list_registered_models(
        self, max_results: int, page_token: str
    ) -> "ListRegisteredModelsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_latest_versions(
        self, name: str, stages: Optional[List[str]]
    ) -> "GetLatestVersionsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def create_model_version(
        self,
        name: str,
        source: str,
        run_id: str,
        tags: Optional[List["ModelVersionTag"]],
        run_link: str,
        description: str,
    ) -> "CreateModelVersionResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def update_model_version(
        self, name: str, version: str, description: str
    ) -> "UpdateModelVersionResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def transition_model_version_stage(
        self, name: str, version: str, stage: str, archive_existing_versions: bool
    ) -> "TransitionModelVersionStageResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_model_version(self, name: str, version: str) -> "DeleteModelVersionResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_model_version(self, name: str, version: str) -> "GetModelVersionResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def search_model_versions(
        self,
        filter: str,
        max_results: int,
        order_by: Optional[List[str]],
        page_token: str,
    ) -> "SearchModelVersionsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_model_version_download_uri(
        self, name: str, version: str
    ) -> "GetModelVersionDownloadUriResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set_registered_model_tag(
        self, name: str, key: str, value: str
    ) -> "SetRegisteredModelTagResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set_model_version_tag(
        self, name: str, version: str, key: str, value: str
    ) -> "SetModelVersionTagResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_registered_model_tag(
        self, name: str, key: str
    ) -> "DeleteRegisteredModelTagResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_model_version_tag(
        self, name: str, version: str, key: str
    ) -> "DeleteModelVersionTagResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_create_registered_model(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "name": request.name,
            "tags": request.tags,
            "description": request.description,
        }

        response = await self.create_registered_model(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_rename_registered_model(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "name": request.name,
            "new_name": request.new_name,
        }

        response = await self.rename_registered_model(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_update_registered_model(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "name": request.name,
            "description": request.description,
        }

        response = await self.update_registered_model(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_delete_registered_model(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "name": request.name,
        }

        response = await self.delete_registered_model(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_get_registered_model(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "name": request.name,
        }

        response = await self.get_registered_model(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_search_registered_models(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "filter": request.filter,
            "max_results": request.max_results,
            "order_by": request.order_by,
            "page_token": request.page_token,
        }

        response = await self.search_registered_models(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_list_registered_models(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "max_results": request.max_results,
            "page_token": request.page_token,
        }

        response = await self.list_registered_models(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_get_latest_versions(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "name": request.name,
            "stages": request.stages,
        }

        response = await self.get_latest_versions(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_create_model_version(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "name": request.name,
            "source": request.source,
            "run_id": request.run_id,
            "tags": request.tags,
            "run_link": request.run_link,
            "description": request.description,
        }

        response = await self.create_model_version(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_update_model_version(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "name": request.name,
            "version": request.version,
            "description": request.description,
        }

        response = await self.update_model_version(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_transition_model_version_stage(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "name": request.name,
            "version": request.version,
            "stage": request.stage,
            "archive_existing_versions": request.archive_existing_versions,
        }

        response = await self.transition_model_version_stage(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_delete_model_version(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "name": request.name,
            "version": request.version,
        }

        response = await self.delete_model_version(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_get_model_version(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "name": request.name,
            "version": request.version,
        }

        response = await self.get_model_version(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_search_model_versions(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "filter": request.filter,
            "max_results": request.max_results,
            "order_by": request.order_by,
            "page_token": request.page_token,
        }

        response = await self.search_model_versions(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_get_model_version_download_uri(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "name": request.name,
            "version": request.version,
        }

        response = await self.get_model_version_download_uri(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_set_registered_model_tag(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "name": request.name,
            "key": request.key,
            "value": request.value,
        }

        response = await self.set_registered_model_tag(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_set_model_version_tag(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "name": request.name,
            "version": request.version,
            "key": request.key,
            "value": request.value,
        }

        response = await self.set_model_version_tag(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_delete_registered_model_tag(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "name": request.name,
            "key": request.key,
        }

        response = await self.delete_registered_model_tag(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_delete_model_version_tag(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "name": request.name,
            "version": request.version,
            "key": request.key,
        }

        response = await self.delete_model_version_tag(**request_kwargs)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/mlflow.ModelRegistryService/createRegisteredModel": grpclib.const.Handler(
                self.__rpc_create_registered_model,
                grpclib.const.Cardinality.UNARY_UNARY,
                CreateRegisteredModel,
                CreateRegisteredModelResponse,
            ),
            "/mlflow.ModelRegistryService/renameRegisteredModel": grpclib.const.Handler(
                self.__rpc_rename_registered_model,
                grpclib.const.Cardinality.UNARY_UNARY,
                RenameRegisteredModel,
                RenameRegisteredModelResponse,
            ),
            "/mlflow.ModelRegistryService/updateRegisteredModel": grpclib.const.Handler(
                self.__rpc_update_registered_model,
                grpclib.const.Cardinality.UNARY_UNARY,
                UpdateRegisteredModel,
                UpdateRegisteredModelResponse,
            ),
            "/mlflow.ModelRegistryService/deleteRegisteredModel": grpclib.const.Handler(
                self.__rpc_delete_registered_model,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeleteRegisteredModel,
                DeleteRegisteredModelResponse,
            ),
            "/mlflow.ModelRegistryService/getRegisteredModel": grpclib.const.Handler(
                self.__rpc_get_registered_model,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetRegisteredModel,
                GetRegisteredModelResponse,
            ),
            "/mlflow.ModelRegistryService/searchRegisteredModels": grpclib.const.Handler(
                self.__rpc_search_registered_models,
                grpclib.const.Cardinality.UNARY_UNARY,
                SearchRegisteredModels,
                SearchRegisteredModelsResponse,
            ),
            "/mlflow.ModelRegistryService/listRegisteredModels": grpclib.const.Handler(
                self.__rpc_list_registered_models,
                grpclib.const.Cardinality.UNARY_UNARY,
                ListRegisteredModels,
                ListRegisteredModelsResponse,
            ),
            "/mlflow.ModelRegistryService/getLatestVersions": grpclib.const.Handler(
                self.__rpc_get_latest_versions,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetLatestVersions,
                GetLatestVersionsResponse,
            ),
            "/mlflow.ModelRegistryService/createModelVersion": grpclib.const.Handler(
                self.__rpc_create_model_version,
                grpclib.const.Cardinality.UNARY_UNARY,
                CreateModelVersion,
                CreateModelVersionResponse,
            ),
            "/mlflow.ModelRegistryService/updateModelVersion": grpclib.const.Handler(
                self.__rpc_update_model_version,
                grpclib.const.Cardinality.UNARY_UNARY,
                UpdateModelVersion,
                UpdateModelVersionResponse,
            ),
            "/mlflow.ModelRegistryService/transitionModelVersionStage": grpclib.const.Handler(
                self.__rpc_transition_model_version_stage,
                grpclib.const.Cardinality.UNARY_UNARY,
                TransitionModelVersionStage,
                TransitionModelVersionStageResponse,
            ),
            "/mlflow.ModelRegistryService/deleteModelVersion": grpclib.const.Handler(
                self.__rpc_delete_model_version,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeleteModelVersion,
                DeleteModelVersionResponse,
            ),
            "/mlflow.ModelRegistryService/getModelVersion": grpclib.const.Handler(
                self.__rpc_get_model_version,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetModelVersion,
                GetModelVersionResponse,
            ),
            "/mlflow.ModelRegistryService/searchModelVersions": grpclib.const.Handler(
                self.__rpc_search_model_versions,
                grpclib.const.Cardinality.UNARY_UNARY,
                SearchModelVersions,
                SearchModelVersionsResponse,
            ),
            "/mlflow.ModelRegistryService/getModelVersionDownloadUri": grpclib.const.Handler(
                self.__rpc_get_model_version_download_uri,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetModelVersionDownloadUri,
                GetModelVersionDownloadUriResponse,
            ),
            "/mlflow.ModelRegistryService/setRegisteredModelTag": grpclib.const.Handler(
                self.__rpc_set_registered_model_tag,
                grpclib.const.Cardinality.UNARY_UNARY,
                SetRegisteredModelTag,
                SetRegisteredModelTagResponse,
            ),
            "/mlflow.ModelRegistryService/setModelVersionTag": grpclib.const.Handler(
                self.__rpc_set_model_version_tag,
                grpclib.const.Cardinality.UNARY_UNARY,
                SetModelVersionTag,
                SetModelVersionTagResponse,
            ),
            "/mlflow.ModelRegistryService/deleteRegisteredModelTag": grpclib.const.Handler(
                self.__rpc_delete_registered_model_tag,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeleteRegisteredModelTag,
                DeleteRegisteredModelTagResponse,
            ),
            "/mlflow.ModelRegistryService/deleteModelVersionTag": grpclib.const.Handler(
                self.__rpc_delete_model_version_tag,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeleteModelVersionTag,
                DeleteModelVersionTagResponse,
            ),
        }


class MlflowServiceBase(ServiceBase):
    async def get_experiment_by_name(self, experiment_name: str) -> "GetExperimentByNameResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def create_experiment(
        self, name: str, artifact_location: str, tags: Optional[List["ExperimentTag"]]
    ) -> "CreateExperimentResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def list_experiments(
        self, view_type: "ViewType", max_results: int, page_token: str
    ) -> "ListExperimentsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_experiment(self, experiment_id: str) -> "GetExperimentResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_experiment(self, experiment_id: str) -> "DeleteExperimentResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def restore_experiment(self, experiment_id: str) -> "RestoreExperimentResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def update_experiment(
        self, experiment_id: str, new_name: str
    ) -> "UpdateExperimentResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def create_run(
        self,
        experiment_id: str,
        user_id: str,
        start_time: int,
        tags: Optional[List["RunTag"]],
    ) -> "CreateRunResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def update_run(
        self, run_id: str, run_uuid: str, status: "RunStatus", end_time: int
    ) -> "UpdateRunResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_run(self, run_id: str) -> "DeleteRunResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def restore_run(self, run_id: str) -> "RestoreRunResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def log_metric(
        self,
        run_id: str,
        run_uuid: str,
        key: str,
        value: float,
        timestamp: int,
        step: int,
    ) -> "LogMetricResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def log_param(
        self, run_id: str, run_uuid: str, key: str, value: str
    ) -> "LogParamResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set_experiment_tag(
        self, experiment_id: str, key: str, value: str
    ) -> "SetExperimentTagResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set_tag(self, run_id: str, run_uuid: str, key: str, value: str) -> "SetTagResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_tag(self, run_id: str, key: str) -> "DeleteTagResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_run(self, run_id: str, run_uuid: str) -> "GetRunResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def search_runs(
        self,
        experiment_ids: Optional[List[str]],
        filter: str,
        run_view_type: "ViewType",
        max_results: int,
        order_by: Optional[List[str]],
        page_token: str,
    ) -> "SearchRunsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def list_artifacts(
        self, run_id: str, run_uuid: str, path: str, page_token: str
    ) -> "ListArtifactsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_metric_history(
        self, run_id: str, run_uuid: str, metric_key: str
    ) -> "GetMetricHistoryResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def log_batch(
        self,
        run_id: str,
        metrics: Optional[List["Metric"]],
        params: Optional[List["Param"]],
        tags: Optional[List["RunTag"]],
    ) -> "LogBatchResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def log_model(self, run_id: str, model_json: str) -> "LogModelResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_experiment_by_name(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "experiment_name": request.experiment_name,
        }

        response = await self.get_experiment_by_name(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_create_experiment(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "name": request.name,
            "artifact_location": request.artifact_location,
            "tags": request.tags,
        }

        response = await self.create_experiment(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_list_experiments(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "view_type": request.view_type,
            "max_results": request.max_results,
            "page_token": request.page_token,
        }

        response = await self.list_experiments(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_get_experiment(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "experiment_id": request.experiment_id,
        }

        response = await self.get_experiment(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_delete_experiment(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "experiment_id": request.experiment_id,
        }

        response = await self.delete_experiment(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_restore_experiment(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "experiment_id": request.experiment_id,
        }

        response = await self.restore_experiment(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_update_experiment(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "experiment_id": request.experiment_id,
            "new_name": request.new_name,
        }

        response = await self.update_experiment(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_create_run(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "experiment_id": request.experiment_id,
            "user_id": request.user_id,
            "start_time": request.start_time,
            "tags": request.tags,
        }

        response = await self.create_run(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_update_run(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "run_id": request.run_id,
            "run_uuid": request.run_uuid,
            "status": request.status,
            "end_time": request.end_time,
        }

        response = await self.update_run(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_delete_run(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "run_id": request.run_id,
        }

        response = await self.delete_run(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_restore_run(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "run_id": request.run_id,
        }

        response = await self.restore_run(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_log_metric(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "run_id": request.run_id,
            "run_uuid": request.run_uuid,
            "key": request.key,
            "value": request.value,
            "timestamp": request.timestamp,
            "step": request.step,
        }

        response = await self.log_metric(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_log_param(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "run_id": request.run_id,
            "run_uuid": request.run_uuid,
            "key": request.key,
            "value": request.value,
        }

        response = await self.log_param(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_set_experiment_tag(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "experiment_id": request.experiment_id,
            "key": request.key,
            "value": request.value,
        }

        response = await self.set_experiment_tag(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_set_tag(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "run_id": request.run_id,
            "run_uuid": request.run_uuid,
            "key": request.key,
            "value": request.value,
        }

        response = await self.set_tag(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_delete_tag(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "run_id": request.run_id,
            "key": request.key,
        }

        response = await self.delete_tag(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_get_run(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "run_id": request.run_id,
            "run_uuid": request.run_uuid,
        }

        response = await self.get_run(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_search_runs(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "experiment_ids": request.experiment_ids,
            "filter": request.filter,
            "run_view_type": request.run_view_type,
            "max_results": request.max_results,
            "order_by": request.order_by,
            "page_token": request.page_token,
        }

        response = await self.search_runs(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_list_artifacts(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "run_id": request.run_id,
            "run_uuid": request.run_uuid,
            "path": request.path,
            "page_token": request.page_token,
        }

        response = await self.list_artifacts(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_get_metric_history(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "run_id": request.run_id,
            "run_uuid": request.run_uuid,
            "metric_key": request.metric_key,
        }

        response = await self.get_metric_history(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_log_batch(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "run_id": request.run_id,
            "metrics": request.metrics,
            "params": request.params,
            "tags": request.tags,
        }

        response = await self.log_batch(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_log_model(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "run_id": request.run_id,
            "model_json": request.model_json,
        }

        response = await self.log_model(**request_kwargs)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/mlflow.MlflowService/getExperimentByName": grpclib.const.Handler(
                self.__rpc_get_experiment_by_name,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetExperimentByName,
                GetExperimentByNameResponse,
            ),
            "/mlflow.MlflowService/createExperiment": grpclib.const.Handler(
                self.__rpc_create_experiment,
                grpclib.const.Cardinality.UNARY_UNARY,
                CreateExperiment,
                CreateExperimentResponse,
            ),
            "/mlflow.MlflowService/listExperiments": grpclib.const.Handler(
                self.__rpc_list_experiments,
                grpclib.const.Cardinality.UNARY_UNARY,
                ListExperiments,
                ListExperimentsResponse,
            ),
            "/mlflow.MlflowService/getExperiment": grpclib.const.Handler(
                self.__rpc_get_experiment,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetExperiment,
                GetExperimentResponse,
            ),
            "/mlflow.MlflowService/deleteExperiment": grpclib.const.Handler(
                self.__rpc_delete_experiment,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeleteExperiment,
                DeleteExperimentResponse,
            ),
            "/mlflow.MlflowService/restoreExperiment": grpclib.const.Handler(
                self.__rpc_restore_experiment,
                grpclib.const.Cardinality.UNARY_UNARY,
                RestoreExperiment,
                RestoreExperimentResponse,
            ),
            "/mlflow.MlflowService/updateExperiment": grpclib.const.Handler(
                self.__rpc_update_experiment,
                grpclib.const.Cardinality.UNARY_UNARY,
                UpdateExperiment,
                UpdateExperimentResponse,
            ),
            "/mlflow.MlflowService/createRun": grpclib.const.Handler(
                self.__rpc_create_run,
                grpclib.const.Cardinality.UNARY_UNARY,
                CreateRun,
                CreateRunResponse,
            ),
            "/mlflow.MlflowService/updateRun": grpclib.const.Handler(
                self.__rpc_update_run,
                grpclib.const.Cardinality.UNARY_UNARY,
                UpdateRun,
                UpdateRunResponse,
            ),
            "/mlflow.MlflowService/deleteRun": grpclib.const.Handler(
                self.__rpc_delete_run,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeleteRun,
                DeleteRunResponse,
            ),
            "/mlflow.MlflowService/restoreRun": grpclib.const.Handler(
                self.__rpc_restore_run,
                grpclib.const.Cardinality.UNARY_UNARY,
                RestoreRun,
                RestoreRunResponse,
            ),
            "/mlflow.MlflowService/logMetric": grpclib.const.Handler(
                self.__rpc_log_metric,
                grpclib.const.Cardinality.UNARY_UNARY,
                LogMetric,
                LogMetricResponse,
            ),
            "/mlflow.MlflowService/logParam": grpclib.const.Handler(
                self.__rpc_log_param,
                grpclib.const.Cardinality.UNARY_UNARY,
                LogParam,
                LogParamResponse,
            ),
            "/mlflow.MlflowService/setExperimentTag": grpclib.const.Handler(
                self.__rpc_set_experiment_tag,
                grpclib.const.Cardinality.UNARY_UNARY,
                SetExperimentTag,
                SetExperimentTagResponse,
            ),
            "/mlflow.MlflowService/setTag": grpclib.const.Handler(
                self.__rpc_set_tag,
                grpclib.const.Cardinality.UNARY_UNARY,
                SetTag,
                SetTagResponse,
            ),
            "/mlflow.MlflowService/deleteTag": grpclib.const.Handler(
                self.__rpc_delete_tag,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeleteTag,
                DeleteTagResponse,
            ),
            "/mlflow.MlflowService/getRun": grpclib.const.Handler(
                self.__rpc_get_run,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetRun,
                GetRunResponse,
            ),
            "/mlflow.MlflowService/searchRuns": grpclib.const.Handler(
                self.__rpc_search_runs,
                grpclib.const.Cardinality.UNARY_UNARY,
                SearchRuns,
                SearchRunsResponse,
            ),
            "/mlflow.MlflowService/listArtifacts": grpclib.const.Handler(
                self.__rpc_list_artifacts,
                grpclib.const.Cardinality.UNARY_UNARY,
                ListArtifacts,
                ListArtifactsResponse,
            ),
            "/mlflow.MlflowService/getMetricHistory": grpclib.const.Handler(
                self.__rpc_get_metric_history,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetMetricHistory,
                GetMetricHistoryResponse,
            ),
            "/mlflow.MlflowService/logBatch": grpclib.const.Handler(
                self.__rpc_log_batch,
                grpclib.const.Cardinality.UNARY_UNARY,
                LogBatch,
                LogBatchResponse,
            ),
            "/mlflow.MlflowService/logModel": grpclib.const.Handler(
                self.__rpc_log_model,
                grpclib.const.Cardinality.UNARY_UNARY,
                LogModel,
                LogModelResponse,
            ),
        }
