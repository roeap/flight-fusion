# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: mlflow/mlflow_artifacts.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import AsyncIterable, AsyncIterator, Dict, Iterable, List, Optional, Union

import betterproto
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase


@dataclass(eq=False, repr=False)
class DownloadArtifact(betterproto.Message):
    path: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class DownloadArtifactResponse(betterproto.Message):
    data: bytes = betterproto.bytes_field(1)


@dataclass(eq=False, repr=False)
class UploadArtifact(betterproto.Message):
    path: str = betterproto.string_field(1)
    data: bytes = betterproto.bytes_field(2)


@dataclass(eq=False, repr=False)
class UploadArtifactResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class ListArtifacts(betterproto.Message):
    # Filter artifacts matching this path (a relative path from the root artifact
    # directory).
    path: Optional[str] = betterproto.string_field(1, optional=True, group="_path")


@dataclass(eq=False, repr=False)
class ListArtifactsResponse(betterproto.Message):
    # File location and metadata for artifacts.
    files: List["FileInfo"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class FileInfo(betterproto.Message):
    # Path relative to the root artifact directory run.
    path: Optional[str] = betterproto.string_field(1, optional=True, group="_path")
    # Whether the path is a directory.
    is_dir: Optional[bool] = betterproto.bool_field(2, optional=True, group="_is_dir")
    # Size in bytes. Unset for directories.
    file_size: Optional[int] = betterproto.int64_field(3, optional=True, group="_file_size")


class MlflowArtifactsServiceStub(betterproto.ServiceStub):
    async def download_artifact(self, *, path: str = "") -> AsyncIterator["DownloadArtifactResponse"]:

        request = DownloadArtifact()
        request.path = path

        async for response in self._unary_stream(
            "/mlflow.artifacts.MlflowArtifactsService/downloadArtifact",
            request,
            DownloadArtifactResponse,
        ):
            yield response

    async def upload_artifact(
        self,
        request_iterator: Union[AsyncIterable["UploadArtifact"], Iterable["UploadArtifact"]],
    ) -> "UploadArtifactResponse":

        return await self._stream_unary(
            "/mlflow.artifacts.MlflowArtifactsService/uploadArtifact",
            request_iterator,
            UploadArtifact,
            UploadArtifactResponse,
        )

    async def list_artifacts(self, *, path: Optional[str] = None) -> "ListArtifactsResponse":

        request = ListArtifacts()
        request.path = path

        return await self._unary_unary(
            "/mlflow.artifacts.MlflowArtifactsService/listArtifacts",
            request,
            ListArtifactsResponse,
        )


class MlflowArtifactsServiceBase(ServiceBase):
    async def download_artifact(self, path: str) -> AsyncIterator["DownloadArtifactResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def upload_artifact(self, request_iterator: AsyncIterator["UploadArtifact"]) -> "UploadArtifactResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def list_artifacts(self, path: Optional[str]) -> "ListArtifactsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_download_artifact(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "path": request.path,
        }

        await self._call_rpc_handler_server_stream(
            self.download_artifact,
            stream,
            request_kwargs,
        )

    async def __rpc_upload_artifact(self, stream: grpclib.server.Stream) -> None:
        request_kwargs = {"request_iterator": stream.__aiter__()}

        response = await self.upload_artifact(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_list_artifacts(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "path": request.path,
        }

        response = await self.list_artifacts(**request_kwargs)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/mlflow.artifacts.MlflowArtifactsService/downloadArtifact": grpclib.const.Handler(
                self.__rpc_download_artifact,
                grpclib.const.Cardinality.UNARY_STREAM,
                DownloadArtifact,
                DownloadArtifactResponse,
            ),
            "/mlflow.artifacts.MlflowArtifactsService/uploadArtifact": grpclib.const.Handler(
                self.__rpc_upload_artifact,
                grpclib.const.Cardinality.STREAM_UNARY,
                UploadArtifact,
                UploadArtifactResponse,
            ),
            "/mlflow.artifacts.MlflowArtifactsService/listArtifacts": grpclib.const.Handler(
                self.__rpc_list_artifacts,
                grpclib.const.Cardinality.UNARY_UNARY,
                ListArtifacts,
                ListArtifactsResponse,
            ),
        }
