/* eslint-disable */
import * as Long from "long";
import * as _m0 from "protobufjs/minimal";

export const protobufPackage = "mlflow";

export enum ModelVersionStatus {
  /** PENDING_REGISTRATION - Request to register a new model version is pending as server performs background tasks. */
  PENDING_REGISTRATION = 1,
  /** FAILED_REGISTRATION - Request to register a new model version has failed. */
  FAILED_REGISTRATION = 2,
  /** READY - Model version is ready for use. */
  READY = 3,
  UNRECOGNIZED = -1,
}

export function modelVersionStatusFromJSON(object: any): ModelVersionStatus {
  switch (object) {
    case 1:
    case "PENDING_REGISTRATION":
      return ModelVersionStatus.PENDING_REGISTRATION;
    case 2:
    case "FAILED_REGISTRATION":
      return ModelVersionStatus.FAILED_REGISTRATION;
    case 3:
    case "READY":
      return ModelVersionStatus.READY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ModelVersionStatus.UNRECOGNIZED;
  }
}

export function modelVersionStatusToJSON(object: ModelVersionStatus): string {
  switch (object) {
    case ModelVersionStatus.PENDING_REGISTRATION:
      return "PENDING_REGISTRATION";
    case ModelVersionStatus.FAILED_REGISTRATION:
      return "FAILED_REGISTRATION";
    case ModelVersionStatus.READY:
      return "READY";
    default:
      return "UNKNOWN";
  }
}

export interface RegisteredModel {
  /** Unique name for the model. */
  name: string;
  /** Timestamp recorded when this ``registered_model`` was created. */
  creationTimestamp: number;
  /** Timestamp recorded when metadata for this ``registered_model`` was last updated. */
  lastUpdatedTimestamp: number;
  /**
   * User that created this ``registered_model``
   * NOTE: this field is not currently returned.
   */
  userId: string;
  /** Description of this ``registered_model``. */
  description: string;
  /**
   * Collection of latest model versions for each stage.
   * Only contains models with current ``READY`` status.
   */
  latestVersions: ModelVersion[];
  /** Tags: Additional metadata key-value pairs for this ``registered_model``. */
  tags: RegisteredModelTag[];
}

export interface ModelVersion {
  /** Unique name of the model */
  name: string;
  /** Model's version number. */
  version: string;
  /** Timestamp recorded when this ``model_version`` was created. */
  creationTimestamp: number;
  /** Timestamp recorded when metadata for this ``model_version`` was last updated. */
  lastUpdatedTimestamp: number;
  /** User that created this ``model_version``. */
  userId: string;
  /** Current stage for this ``model_version``. */
  currentStage: string;
  /** Description of this ``model_version``. */
  description: string;
  /** URI indicating the location of the source model artifacts, used when creating ``model_version`` */
  source: string;
  /**
   * MLflow run ID used when creating ``model_version``, if ``source`` was generated by an
   * experiment run stored in MLflow tracking server.
   */
  runId: string;
  /** Current status of ``model_version`` */
  status: ModelVersionStatus;
  /** Details on current ``status``, if it is pending or failed. */
  statusMessage: string;
  /** Tags: Additional metadata key-value pairs for this ``model_version``. */
  tags: ModelVersionTag[];
  /** Run Link: Direct link to the run that generated this version */
  runLink: string;
}

export interface CreateRegisteredModel {
  /** Register models under this name */
  name: string;
  /** Additional metadata for registered model. */
  tags: RegisteredModelTag[];
  /** Optional description for registered model. */
  description: string;
}

export interface CreateRegisteredModel_Response {
  registeredModel: RegisteredModel | undefined;
}

export interface RenameRegisteredModel {
  /** Registered model unique name identifier. */
  name: string;
  /** If provided, updates the name for this ``registered_model``. */
  newName: string;
}

export interface RenameRegisteredModel_Response {
  registeredModel: RegisteredModel | undefined;
}

export interface UpdateRegisteredModel {
  /** Registered model unique name identifier. */
  name: string;
  /** If provided, updates the description for this ``registered_model``. */
  description: string;
}

export interface UpdateRegisteredModel_Response {
  registeredModel: RegisteredModel | undefined;
}

export interface DeleteRegisteredModel {
  /** Registered model unique name identifier. */
  name: string;
}

export interface DeleteRegisteredModel_Response {}

export interface GetRegisteredModel {
  /** Registered model unique name identifier. */
  name: string;
}

export interface GetRegisteredModel_Response {
  registeredModel: RegisteredModel | undefined;
}

export interface ListRegisteredModels {
  /** Maximum number of registered models desired. Max threshold is 1000. */
  maxResults: number;
  /** Pagination token to go to the next page based on a previous query. */
  pageToken: string;
}

export interface ListRegisteredModels_Response {
  registeredModels: RegisteredModel[];
  /** Pagination token to request next page of models for the same query. */
  nextPageToken: string;
}

export interface SearchRegisteredModels {
  /**
   * String filter condition, like "name LIKE 'my-model-name'".
   * Interpreted in the backend automatically as "name LIKE '%my-model-name%'".
   * Single boolean condition, with string values wrapped in single quotes.
   */
  filter: string;
  /** Maximum number of models desired. Default is 100. Max threshold is 1000. */
  maxResults: number;
  /**
   * List of columns for ordering search results, which can include model name and last updated
   * timestamp with an optional "DESC" or "ASC" annotation, where "ASC" is the default.
   * Tiebreaks are done by model name ASC.
   */
  orderBy: string[];
  /** Pagination token to go to the next page based on a previous search query. */
  pageToken: string;
}

export interface SearchRegisteredModels_Response {
  /** Registered Models that match the search criteria. */
  registeredModels: RegisteredModel[];
  /** Pagination token to request the next page of models. */
  nextPageToken: string;
}

export interface GetLatestVersions {
  /** Registered model unique name identifier. */
  name: string;
  /** List of stages. */
  stages: string[];
}

export interface GetLatestVersions_Response {
  /**
   * Latest version models for each requests stage. Only return models with current ``READY`` status.
   * If no ``stages`` provided, returns the latest version for each stage, including ``"None"``.
   */
  modelVersions: ModelVersion[];
}

export interface CreateModelVersion {
  /** Register model under this name */
  name: string;
  /** URI indicating the location of the model artifacts. */
  source: string;
  /**
   * MLflow run ID for correlation, if ``source`` was generated by an experiment run in
   * MLflow tracking server
   */
  runId: string;
  /** Additional metadata for model version. */
  tags: ModelVersionTag[];
  /**
   * MLflow run link - this is the exact link of the run that generated this model version,
   * potentially hosted at another instance of MLflow.
   */
  runLink: string;
  /** Optional description for model version. */
  description: string;
}

export interface CreateModelVersion_Response {
  /** Return new version number generated for this model in registry. */
  modelVersion: ModelVersion | undefined;
}

export interface UpdateModelVersion {
  /** Name of the registered model */
  name: string;
  /** Model version number */
  version: string;
  /** If provided, updates the description for this ``registered_model``. */
  description: string;
}

export interface UpdateModelVersion_Response {
  /** Return new version number generated for this model in registry. */
  modelVersion: ModelVersion | undefined;
}

export interface TransitionModelVersionStage {
  /** Name of the registered model */
  name: string;
  /** Model version number */
  version: string;
  /** Transition `model_version` to new stage. */
  stage: string;
  /**
   * When transitioning a model version to a particular stage, this flag dictates whether all
   * existing model versions in that stage should be atomically moved to the "archived" stage.
   * This ensures that at-most-one model version exists in the target stage.
   * This field is *required* when transitioning a model versions's stage
   */
  archiveExistingVersions: boolean;
}

export interface TransitionModelVersionStage_Response {
  /** Updated model version */
  modelVersion: ModelVersion | undefined;
}

export interface DeleteModelVersion {
  /** Name of the registered model */
  name: string;
  /** Model version number */
  version: string;
}

export interface DeleteModelVersion_Response {}

export interface GetModelVersion {
  /** Name of the registered model */
  name: string;
  /** Model version number */
  version: string;
}

export interface GetModelVersion_Response {
  modelVersion: ModelVersion | undefined;
}

export interface SearchModelVersions {
  /**
   * String filter condition, like "name='my-model-name'". Must be a single boolean condition,
   * with string values wrapped in single quotes.
   */
  filter: string;
  /** Maximum number of models desired. Max threshold is 200K. */
  maxResults: number;
  /**
   * List of columns to be ordered by including model name, version, stage with an
   * optional "DESC" or "ASC" annotation, where "ASC" is the default.
   * Tiebreaks are done by latest stage transition timestamp, followed by name ASC, followed by
   * version DESC.
   */
  orderBy: string[];
  /** Pagination token to go to next page based on previous search query. */
  pageToken: string;
}

export interface SearchModelVersions_Response {
  /** Models that match the search criteria */
  modelVersions: ModelVersion[];
  /** Pagination token to request next page of models for the same search query. */
  nextPageToken: string;
}

export interface GetModelVersionDownloadUri {
  /** Name of the registered model */
  name: string;
  /** Model version number */
  version: string;
}

export interface GetModelVersionDownloadUri_Response {
  /** URI corresponding to where artifacts for this model version are stored. */
  artifactUri: string;
}

/** Tag for a model version. */
export interface ModelVersionTag {
  /** The tag key. */
  key: string;
  /** The tag value. */
  value: string;
}

/** Tag for a registered model */
export interface RegisteredModelTag {
  /** The tag key. */
  key: string;
  /** The tag value. */
  value: string;
}

export interface SetRegisteredModelTag {
  /** Unique name of the model. */
  name: string;
  /**
   * Name of the tag. Maximum size depends on storage backend.
   * If a tag with this name already exists, its preexisting value will be replaced by the specified `value`.
   * All storage backends are guaranteed to support key values up to 250 bytes in size.
   */
  key: string;
  /**
   * String value of the tag being logged. Maximum size depends on storage backend.
   * All storage backends are guaranteed to support key values up to 5000 bytes in size.
   */
  value: string;
}

export interface SetRegisteredModelTag_Response {}

export interface SetModelVersionTag {
  /** Unique name of the model. */
  name: string;
  /** Model version number. */
  version: string;
  /**
   * Name of the tag. Maximum size depends on storage backend.
   * If a tag with this name already exists, its preexisting value will be replaced by the specified `value`.
   * All storage backends are guaranteed to support key values up to 250 bytes in size.
   */
  key: string;
  /**
   * String value of the tag being logged. Maximum size depends on storage backend.
   * All storage backends are guaranteed to support key values up to 5000 bytes in size.
   */
  value: string;
}

export interface SetModelVersionTag_Response {}

export interface DeleteRegisteredModelTag {
  /** Name of the registered model that the tag was logged under. */
  name: string;
  /** Name of the tag. The name must be an exact match; wild-card deletion is not supported. Maximum size is 250 bytes. */
  key: string;
}

export interface DeleteRegisteredModelTag_Response {}

export interface DeleteModelVersionTag {
  /** Name of the registered model that the tag was logged under. */
  name: string;
  /** Model version number that the tag was logged under. */
  version: string;
  /** Name of the tag. The name must be an exact match; wild-card deletion is not supported. Maximum size is 250 bytes. */
  key: string;
}

export interface DeleteModelVersionTag_Response {}

function createBaseRegisteredModel(): RegisteredModel {
  return {
    name: "",
    creationTimestamp: 0,
    lastUpdatedTimestamp: 0,
    userId: "",
    description: "",
    latestVersions: [],
    tags: [],
  };
}

export const RegisteredModel = {
  encode(
    message: RegisteredModel,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.creationTimestamp !== 0) {
      writer.uint32(16).int64(message.creationTimestamp);
    }
    if (message.lastUpdatedTimestamp !== 0) {
      writer.uint32(24).int64(message.lastUpdatedTimestamp);
    }
    if (message.userId !== "") {
      writer.uint32(34).string(message.userId);
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    for (const v of message.latestVersions) {
      ModelVersion.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    for (const v of message.tags) {
      RegisteredModelTag.encode(v!, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RegisteredModel {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisteredModel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.creationTimestamp = longToNumber(reader.int64() as Long);
          break;
        case 3:
          message.lastUpdatedTimestamp = longToNumber(reader.int64() as Long);
          break;
        case 4:
          message.userId = reader.string();
          break;
        case 5:
          message.description = reader.string();
          break;
        case 6:
          message.latestVersions.push(
            ModelVersion.decode(reader, reader.uint32())
          );
          break;
        case 7:
          message.tags.push(RegisteredModelTag.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RegisteredModel {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      creationTimestamp: isSet(object.creationTimestamp)
        ? Number(object.creationTimestamp)
        : 0,
      lastUpdatedTimestamp: isSet(object.lastUpdatedTimestamp)
        ? Number(object.lastUpdatedTimestamp)
        : 0,
      userId: isSet(object.userId) ? String(object.userId) : "",
      description: isSet(object.description) ? String(object.description) : "",
      latestVersions: Array.isArray(object?.latestVersions)
        ? object.latestVersions.map((e: any) => ModelVersion.fromJSON(e))
        : [],
      tags: Array.isArray(object?.tags)
        ? object.tags.map((e: any) => RegisteredModelTag.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RegisteredModel): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.creationTimestamp !== undefined &&
      (obj.creationTimestamp = Math.round(message.creationTimestamp));
    message.lastUpdatedTimestamp !== undefined &&
      (obj.lastUpdatedTimestamp = Math.round(message.lastUpdatedTimestamp));
    message.userId !== undefined && (obj.userId = message.userId);
    message.description !== undefined &&
      (obj.description = message.description);
    if (message.latestVersions) {
      obj.latestVersions = message.latestVersions.map((e) =>
        e ? ModelVersion.toJSON(e) : undefined
      );
    } else {
      obj.latestVersions = [];
    }
    if (message.tags) {
      obj.tags = message.tags.map((e) =>
        e ? RegisteredModelTag.toJSON(e) : undefined
      );
    } else {
      obj.tags = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<RegisteredModel>, I>>(
    object: I
  ): RegisteredModel {
    const message = createBaseRegisteredModel();
    message.name = object.name ?? "";
    message.creationTimestamp = object.creationTimestamp ?? 0;
    message.lastUpdatedTimestamp = object.lastUpdatedTimestamp ?? 0;
    message.userId = object.userId ?? "";
    message.description = object.description ?? "";
    message.latestVersions =
      object.latestVersions?.map((e) => ModelVersion.fromPartial(e)) || [];
    message.tags =
      object.tags?.map((e) => RegisteredModelTag.fromPartial(e)) || [];
    return message;
  },
};

function createBaseModelVersion(): ModelVersion {
  return {
    name: "",
    version: "",
    creationTimestamp: 0,
    lastUpdatedTimestamp: 0,
    userId: "",
    currentStage: "",
    description: "",
    source: "",
    runId: "",
    status: 1,
    statusMessage: "",
    tags: [],
    runLink: "",
  };
}

export const ModelVersion = {
  encode(
    message: ModelVersion,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    if (message.creationTimestamp !== 0) {
      writer.uint32(24).int64(message.creationTimestamp);
    }
    if (message.lastUpdatedTimestamp !== 0) {
      writer.uint32(32).int64(message.lastUpdatedTimestamp);
    }
    if (message.userId !== "") {
      writer.uint32(42).string(message.userId);
    }
    if (message.currentStage !== "") {
      writer.uint32(50).string(message.currentStage);
    }
    if (message.description !== "") {
      writer.uint32(58).string(message.description);
    }
    if (message.source !== "") {
      writer.uint32(66).string(message.source);
    }
    if (message.runId !== "") {
      writer.uint32(74).string(message.runId);
    }
    if (message.status !== 1) {
      writer.uint32(80).int32(message.status);
    }
    if (message.statusMessage !== "") {
      writer.uint32(90).string(message.statusMessage);
    }
    for (const v of message.tags) {
      ModelVersionTag.encode(v!, writer.uint32(98).fork()).ldelim();
    }
    if (message.runLink !== "") {
      writer.uint32(106).string(message.runLink);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ModelVersion {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelVersion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.version = reader.string();
          break;
        case 3:
          message.creationTimestamp = longToNumber(reader.int64() as Long);
          break;
        case 4:
          message.lastUpdatedTimestamp = longToNumber(reader.int64() as Long);
          break;
        case 5:
          message.userId = reader.string();
          break;
        case 6:
          message.currentStage = reader.string();
          break;
        case 7:
          message.description = reader.string();
          break;
        case 8:
          message.source = reader.string();
          break;
        case 9:
          message.runId = reader.string();
          break;
        case 10:
          message.status = reader.int32() as any;
          break;
        case 11:
          message.statusMessage = reader.string();
          break;
        case 12:
          message.tags.push(ModelVersionTag.decode(reader, reader.uint32()));
          break;
        case 13:
          message.runLink = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ModelVersion {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      version: isSet(object.version) ? String(object.version) : "",
      creationTimestamp: isSet(object.creationTimestamp)
        ? Number(object.creationTimestamp)
        : 0,
      lastUpdatedTimestamp: isSet(object.lastUpdatedTimestamp)
        ? Number(object.lastUpdatedTimestamp)
        : 0,
      userId: isSet(object.userId) ? String(object.userId) : "",
      currentStage: isSet(object.currentStage)
        ? String(object.currentStage)
        : "",
      description: isSet(object.description) ? String(object.description) : "",
      source: isSet(object.source) ? String(object.source) : "",
      runId: isSet(object.runId) ? String(object.runId) : "",
      status: isSet(object.status)
        ? modelVersionStatusFromJSON(object.status)
        : 1,
      statusMessage: isSet(object.statusMessage)
        ? String(object.statusMessage)
        : "",
      tags: Array.isArray(object?.tags)
        ? object.tags.map((e: any) => ModelVersionTag.fromJSON(e))
        : [],
      runLink: isSet(object.runLink) ? String(object.runLink) : "",
    };
  },

  toJSON(message: ModelVersion): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.version !== undefined && (obj.version = message.version);
    message.creationTimestamp !== undefined &&
      (obj.creationTimestamp = Math.round(message.creationTimestamp));
    message.lastUpdatedTimestamp !== undefined &&
      (obj.lastUpdatedTimestamp = Math.round(message.lastUpdatedTimestamp));
    message.userId !== undefined && (obj.userId = message.userId);
    message.currentStage !== undefined &&
      (obj.currentStage = message.currentStage);
    message.description !== undefined &&
      (obj.description = message.description);
    message.source !== undefined && (obj.source = message.source);
    message.runId !== undefined && (obj.runId = message.runId);
    message.status !== undefined &&
      (obj.status = modelVersionStatusToJSON(message.status));
    message.statusMessage !== undefined &&
      (obj.statusMessage = message.statusMessage);
    if (message.tags) {
      obj.tags = message.tags.map((e) =>
        e ? ModelVersionTag.toJSON(e) : undefined
      );
    } else {
      obj.tags = [];
    }
    message.runLink !== undefined && (obj.runLink = message.runLink);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ModelVersion>, I>>(
    object: I
  ): ModelVersion {
    const message = createBaseModelVersion();
    message.name = object.name ?? "";
    message.version = object.version ?? "";
    message.creationTimestamp = object.creationTimestamp ?? 0;
    message.lastUpdatedTimestamp = object.lastUpdatedTimestamp ?? 0;
    message.userId = object.userId ?? "";
    message.currentStage = object.currentStage ?? "";
    message.description = object.description ?? "";
    message.source = object.source ?? "";
    message.runId = object.runId ?? "";
    message.status = object.status ?? 1;
    message.statusMessage = object.statusMessage ?? "";
    message.tags =
      object.tags?.map((e) => ModelVersionTag.fromPartial(e)) || [];
    message.runLink = object.runLink ?? "";
    return message;
  },
};

function createBaseCreateRegisteredModel(): CreateRegisteredModel {
  return { name: "", tags: [], description: "" };
}

export const CreateRegisteredModel = {
  encode(
    message: CreateRegisteredModel,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.tags) {
      RegisteredModelTag.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): CreateRegisteredModel {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateRegisteredModel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.tags.push(RegisteredModelTag.decode(reader, reader.uint32()));
          break;
        case 3:
          message.description = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CreateRegisteredModel {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      tags: Array.isArray(object?.tags)
        ? object.tags.map((e: any) => RegisteredModelTag.fromJSON(e))
        : [],
      description: isSet(object.description) ? String(object.description) : "",
    };
  },

  toJSON(message: CreateRegisteredModel): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    if (message.tags) {
      obj.tags = message.tags.map((e) =>
        e ? RegisteredModelTag.toJSON(e) : undefined
      );
    } else {
      obj.tags = [];
    }
    message.description !== undefined &&
      (obj.description = message.description);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<CreateRegisteredModel>, I>>(
    object: I
  ): CreateRegisteredModel {
    const message = createBaseCreateRegisteredModel();
    message.name = object.name ?? "";
    message.tags =
      object.tags?.map((e) => RegisteredModelTag.fromPartial(e)) || [];
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseCreateRegisteredModel_Response(): CreateRegisteredModel_Response {
  return { registeredModel: undefined };
}

export const CreateRegisteredModel_Response = {
  encode(
    message: CreateRegisteredModel_Response,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.registeredModel !== undefined) {
      RegisteredModel.encode(
        message.registeredModel,
        writer.uint32(10).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): CreateRegisteredModel_Response {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateRegisteredModel_Response();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.registeredModel = RegisteredModel.decode(
            reader,
            reader.uint32()
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CreateRegisteredModel_Response {
    return {
      registeredModel: isSet(object.registeredModel)
        ? RegisteredModel.fromJSON(object.registeredModel)
        : undefined,
    };
  },

  toJSON(message: CreateRegisteredModel_Response): unknown {
    const obj: any = {};
    message.registeredModel !== undefined &&
      (obj.registeredModel = message.registeredModel
        ? RegisteredModel.toJSON(message.registeredModel)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<CreateRegisteredModel_Response>, I>>(
    object: I
  ): CreateRegisteredModel_Response {
    const message = createBaseCreateRegisteredModel_Response();
    message.registeredModel =
      object.registeredModel !== undefined && object.registeredModel !== null
        ? RegisteredModel.fromPartial(object.registeredModel)
        : undefined;
    return message;
  },
};

function createBaseRenameRegisteredModel(): RenameRegisteredModel {
  return { name: "", newName: "" };
}

export const RenameRegisteredModel = {
  encode(
    message: RenameRegisteredModel,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.newName !== "") {
      writer.uint32(18).string(message.newName);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): RenameRegisteredModel {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRenameRegisteredModel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.newName = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RenameRegisteredModel {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      newName: isSet(object.newName) ? String(object.newName) : "",
    };
  },

  toJSON(message: RenameRegisteredModel): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.newName !== undefined && (obj.newName = message.newName);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<RenameRegisteredModel>, I>>(
    object: I
  ): RenameRegisteredModel {
    const message = createBaseRenameRegisteredModel();
    message.name = object.name ?? "";
    message.newName = object.newName ?? "";
    return message;
  },
};

function createBaseRenameRegisteredModel_Response(): RenameRegisteredModel_Response {
  return { registeredModel: undefined };
}

export const RenameRegisteredModel_Response = {
  encode(
    message: RenameRegisteredModel_Response,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.registeredModel !== undefined) {
      RegisteredModel.encode(
        message.registeredModel,
        writer.uint32(10).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): RenameRegisteredModel_Response {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRenameRegisteredModel_Response();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.registeredModel = RegisteredModel.decode(
            reader,
            reader.uint32()
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RenameRegisteredModel_Response {
    return {
      registeredModel: isSet(object.registeredModel)
        ? RegisteredModel.fromJSON(object.registeredModel)
        : undefined,
    };
  },

  toJSON(message: RenameRegisteredModel_Response): unknown {
    const obj: any = {};
    message.registeredModel !== undefined &&
      (obj.registeredModel = message.registeredModel
        ? RegisteredModel.toJSON(message.registeredModel)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<RenameRegisteredModel_Response>, I>>(
    object: I
  ): RenameRegisteredModel_Response {
    const message = createBaseRenameRegisteredModel_Response();
    message.registeredModel =
      object.registeredModel !== undefined && object.registeredModel !== null
        ? RegisteredModel.fromPartial(object.registeredModel)
        : undefined;
    return message;
  },
};

function createBaseUpdateRegisteredModel(): UpdateRegisteredModel {
  return { name: "", description: "" };
}

export const UpdateRegisteredModel = {
  encode(
    message: UpdateRegisteredModel,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): UpdateRegisteredModel {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateRegisteredModel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.description = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): UpdateRegisteredModel {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      description: isSet(object.description) ? String(object.description) : "",
    };
  },

  toJSON(message: UpdateRegisteredModel): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.description !== undefined &&
      (obj.description = message.description);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<UpdateRegisteredModel>, I>>(
    object: I
  ): UpdateRegisteredModel {
    const message = createBaseUpdateRegisteredModel();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseUpdateRegisteredModel_Response(): UpdateRegisteredModel_Response {
  return { registeredModel: undefined };
}

export const UpdateRegisteredModel_Response = {
  encode(
    message: UpdateRegisteredModel_Response,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.registeredModel !== undefined) {
      RegisteredModel.encode(
        message.registeredModel,
        writer.uint32(10).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): UpdateRegisteredModel_Response {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateRegisteredModel_Response();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.registeredModel = RegisteredModel.decode(
            reader,
            reader.uint32()
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): UpdateRegisteredModel_Response {
    return {
      registeredModel: isSet(object.registeredModel)
        ? RegisteredModel.fromJSON(object.registeredModel)
        : undefined,
    };
  },

  toJSON(message: UpdateRegisteredModel_Response): unknown {
    const obj: any = {};
    message.registeredModel !== undefined &&
      (obj.registeredModel = message.registeredModel
        ? RegisteredModel.toJSON(message.registeredModel)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<UpdateRegisteredModel_Response>, I>>(
    object: I
  ): UpdateRegisteredModel_Response {
    const message = createBaseUpdateRegisteredModel_Response();
    message.registeredModel =
      object.registeredModel !== undefined && object.registeredModel !== null
        ? RegisteredModel.fromPartial(object.registeredModel)
        : undefined;
    return message;
  },
};

function createBaseDeleteRegisteredModel(): DeleteRegisteredModel {
  return { name: "" };
}

export const DeleteRegisteredModel = {
  encode(
    message: DeleteRegisteredModel,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): DeleteRegisteredModel {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteRegisteredModel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DeleteRegisteredModel {
    return {
      name: isSet(object.name) ? String(object.name) : "",
    };
  },

  toJSON(message: DeleteRegisteredModel): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<DeleteRegisteredModel>, I>>(
    object: I
  ): DeleteRegisteredModel {
    const message = createBaseDeleteRegisteredModel();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDeleteRegisteredModel_Response(): DeleteRegisteredModel_Response {
  return {};
}

export const DeleteRegisteredModel_Response = {
  encode(
    _: DeleteRegisteredModel_Response,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): DeleteRegisteredModel_Response {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteRegisteredModel_Response();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): DeleteRegisteredModel_Response {
    return {};
  },

  toJSON(_: DeleteRegisteredModel_Response): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<DeleteRegisteredModel_Response>, I>>(
    _: I
  ): DeleteRegisteredModel_Response {
    const message = createBaseDeleteRegisteredModel_Response();
    return message;
  },
};

function createBaseGetRegisteredModel(): GetRegisteredModel {
  return { name: "" };
}

export const GetRegisteredModel = {
  encode(
    message: GetRegisteredModel,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetRegisteredModel {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRegisteredModel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetRegisteredModel {
    return {
      name: isSet(object.name) ? String(object.name) : "",
    };
  },

  toJSON(message: GetRegisteredModel): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetRegisteredModel>, I>>(
    object: I
  ): GetRegisteredModel {
    const message = createBaseGetRegisteredModel();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseGetRegisteredModel_Response(): GetRegisteredModel_Response {
  return { registeredModel: undefined };
}

export const GetRegisteredModel_Response = {
  encode(
    message: GetRegisteredModel_Response,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.registeredModel !== undefined) {
      RegisteredModel.encode(
        message.registeredModel,
        writer.uint32(10).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GetRegisteredModel_Response {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRegisteredModel_Response();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.registeredModel = RegisteredModel.decode(
            reader,
            reader.uint32()
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetRegisteredModel_Response {
    return {
      registeredModel: isSet(object.registeredModel)
        ? RegisteredModel.fromJSON(object.registeredModel)
        : undefined,
    };
  },

  toJSON(message: GetRegisteredModel_Response): unknown {
    const obj: any = {};
    message.registeredModel !== undefined &&
      (obj.registeredModel = message.registeredModel
        ? RegisteredModel.toJSON(message.registeredModel)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetRegisteredModel_Response>, I>>(
    object: I
  ): GetRegisteredModel_Response {
    const message = createBaseGetRegisteredModel_Response();
    message.registeredModel =
      object.registeredModel !== undefined && object.registeredModel !== null
        ? RegisteredModel.fromPartial(object.registeredModel)
        : undefined;
    return message;
  },
};

function createBaseListRegisteredModels(): ListRegisteredModels {
  return { maxResults: 0, pageToken: "" };
}

export const ListRegisteredModels = {
  encode(
    message: ListRegisteredModels,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.maxResults !== 0) {
      writer.uint32(8).int64(message.maxResults);
    }
    if (message.pageToken !== "") {
      writer.uint32(18).string(message.pageToken);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): ListRegisteredModels {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRegisteredModels();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.maxResults = longToNumber(reader.int64() as Long);
          break;
        case 2:
          message.pageToken = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ListRegisteredModels {
    return {
      maxResults: isSet(object.maxResults) ? Number(object.maxResults) : 0,
      pageToken: isSet(object.pageToken) ? String(object.pageToken) : "",
    };
  },

  toJSON(message: ListRegisteredModels): unknown {
    const obj: any = {};
    message.maxResults !== undefined &&
      (obj.maxResults = Math.round(message.maxResults));
    message.pageToken !== undefined && (obj.pageToken = message.pageToken);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ListRegisteredModels>, I>>(
    object: I
  ): ListRegisteredModels {
    const message = createBaseListRegisteredModels();
    message.maxResults = object.maxResults ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListRegisteredModels_Response(): ListRegisteredModels_Response {
  return { registeredModels: [], nextPageToken: "" };
}

export const ListRegisteredModels_Response = {
  encode(
    message: ListRegisteredModels_Response,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    for (const v of message.registeredModels) {
      RegisteredModel.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): ListRegisteredModels_Response {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRegisteredModels_Response();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.registeredModels.push(
            RegisteredModel.decode(reader, reader.uint32())
          );
          break;
        case 2:
          message.nextPageToken = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ListRegisteredModels_Response {
    return {
      registeredModels: Array.isArray(object?.registeredModels)
        ? object.registeredModels.map((e: any) => RegisteredModel.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken)
        ? String(object.nextPageToken)
        : "",
    };
  },

  toJSON(message: ListRegisteredModels_Response): unknown {
    const obj: any = {};
    if (message.registeredModels) {
      obj.registeredModels = message.registeredModels.map((e) =>
        e ? RegisteredModel.toJSON(e) : undefined
      );
    } else {
      obj.registeredModels = [];
    }
    message.nextPageToken !== undefined &&
      (obj.nextPageToken = message.nextPageToken);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ListRegisteredModels_Response>, I>>(
    object: I
  ): ListRegisteredModels_Response {
    const message = createBaseListRegisteredModels_Response();
    message.registeredModels =
      object.registeredModels?.map((e) => RegisteredModel.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseSearchRegisteredModels(): SearchRegisteredModels {
  return { filter: "", maxResults: 0, orderBy: [], pageToken: "" };
}

export const SearchRegisteredModels = {
  encode(
    message: SearchRegisteredModels,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.filter !== "") {
      writer.uint32(10).string(message.filter);
    }
    if (message.maxResults !== 0) {
      writer.uint32(16).int64(message.maxResults);
    }
    for (const v of message.orderBy) {
      writer.uint32(26).string(v!);
    }
    if (message.pageToken !== "") {
      writer.uint32(34).string(message.pageToken);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): SearchRegisteredModels {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRegisteredModels();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.filter = reader.string();
          break;
        case 2:
          message.maxResults = longToNumber(reader.int64() as Long);
          break;
        case 3:
          message.orderBy.push(reader.string());
          break;
        case 4:
          message.pageToken = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SearchRegisteredModels {
    return {
      filter: isSet(object.filter) ? String(object.filter) : "",
      maxResults: isSet(object.maxResults) ? Number(object.maxResults) : 0,
      orderBy: Array.isArray(object?.orderBy)
        ? object.orderBy.map((e: any) => String(e))
        : [],
      pageToken: isSet(object.pageToken) ? String(object.pageToken) : "",
    };
  },

  toJSON(message: SearchRegisteredModels): unknown {
    const obj: any = {};
    message.filter !== undefined && (obj.filter = message.filter);
    message.maxResults !== undefined &&
      (obj.maxResults = Math.round(message.maxResults));
    if (message.orderBy) {
      obj.orderBy = message.orderBy.map((e) => e);
    } else {
      obj.orderBy = [];
    }
    message.pageToken !== undefined && (obj.pageToken = message.pageToken);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SearchRegisteredModels>, I>>(
    object: I
  ): SearchRegisteredModels {
    const message = createBaseSearchRegisteredModels();
    message.filter = object.filter ?? "";
    message.maxResults = object.maxResults ?? 0;
    message.orderBy = object.orderBy?.map((e) => e) || [];
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseSearchRegisteredModels_Response(): SearchRegisteredModels_Response {
  return { registeredModels: [], nextPageToken: "" };
}

export const SearchRegisteredModels_Response = {
  encode(
    message: SearchRegisteredModels_Response,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    for (const v of message.registeredModels) {
      RegisteredModel.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): SearchRegisteredModels_Response {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRegisteredModels_Response();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.registeredModels.push(
            RegisteredModel.decode(reader, reader.uint32())
          );
          break;
        case 2:
          message.nextPageToken = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SearchRegisteredModels_Response {
    return {
      registeredModels: Array.isArray(object?.registeredModels)
        ? object.registeredModels.map((e: any) => RegisteredModel.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken)
        ? String(object.nextPageToken)
        : "",
    };
  },

  toJSON(message: SearchRegisteredModels_Response): unknown {
    const obj: any = {};
    if (message.registeredModels) {
      obj.registeredModels = message.registeredModels.map((e) =>
        e ? RegisteredModel.toJSON(e) : undefined
      );
    } else {
      obj.registeredModels = [];
    }
    message.nextPageToken !== undefined &&
      (obj.nextPageToken = message.nextPageToken);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SearchRegisteredModels_Response>, I>>(
    object: I
  ): SearchRegisteredModels_Response {
    const message = createBaseSearchRegisteredModels_Response();
    message.registeredModels =
      object.registeredModels?.map((e) => RegisteredModel.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetLatestVersions(): GetLatestVersions {
  return { name: "", stages: [] };
}

export const GetLatestVersions = {
  encode(
    message: GetLatestVersions,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.stages) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetLatestVersions {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLatestVersions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.stages.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetLatestVersions {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      stages: Array.isArray(object?.stages)
        ? object.stages.map((e: any) => String(e))
        : [],
    };
  },

  toJSON(message: GetLatestVersions): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    if (message.stages) {
      obj.stages = message.stages.map((e) => e);
    } else {
      obj.stages = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetLatestVersions>, I>>(
    object: I
  ): GetLatestVersions {
    const message = createBaseGetLatestVersions();
    message.name = object.name ?? "";
    message.stages = object.stages?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetLatestVersions_Response(): GetLatestVersions_Response {
  return { modelVersions: [] };
}

export const GetLatestVersions_Response = {
  encode(
    message: GetLatestVersions_Response,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    for (const v of message.modelVersions) {
      ModelVersion.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GetLatestVersions_Response {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLatestVersions_Response();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.modelVersions.push(
            ModelVersion.decode(reader, reader.uint32())
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetLatestVersions_Response {
    return {
      modelVersions: Array.isArray(object?.modelVersions)
        ? object.modelVersions.map((e: any) => ModelVersion.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetLatestVersions_Response): unknown {
    const obj: any = {};
    if (message.modelVersions) {
      obj.modelVersions = message.modelVersions.map((e) =>
        e ? ModelVersion.toJSON(e) : undefined
      );
    } else {
      obj.modelVersions = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetLatestVersions_Response>, I>>(
    object: I
  ): GetLatestVersions_Response {
    const message = createBaseGetLatestVersions_Response();
    message.modelVersions =
      object.modelVersions?.map((e) => ModelVersion.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCreateModelVersion(): CreateModelVersion {
  return {
    name: "",
    source: "",
    runId: "",
    tags: [],
    runLink: "",
    description: "",
  };
}

export const CreateModelVersion = {
  encode(
    message: CreateModelVersion,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.source !== "") {
      writer.uint32(18).string(message.source);
    }
    if (message.runId !== "") {
      writer.uint32(26).string(message.runId);
    }
    for (const v of message.tags) {
      ModelVersionTag.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    if (message.runLink !== "") {
      writer.uint32(42).string(message.runLink);
    }
    if (message.description !== "") {
      writer.uint32(50).string(message.description);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateModelVersion {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateModelVersion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.source = reader.string();
          break;
        case 3:
          message.runId = reader.string();
          break;
        case 4:
          message.tags.push(ModelVersionTag.decode(reader, reader.uint32()));
          break;
        case 5:
          message.runLink = reader.string();
          break;
        case 6:
          message.description = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CreateModelVersion {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      source: isSet(object.source) ? String(object.source) : "",
      runId: isSet(object.runId) ? String(object.runId) : "",
      tags: Array.isArray(object?.tags)
        ? object.tags.map((e: any) => ModelVersionTag.fromJSON(e))
        : [],
      runLink: isSet(object.runLink) ? String(object.runLink) : "",
      description: isSet(object.description) ? String(object.description) : "",
    };
  },

  toJSON(message: CreateModelVersion): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.source !== undefined && (obj.source = message.source);
    message.runId !== undefined && (obj.runId = message.runId);
    if (message.tags) {
      obj.tags = message.tags.map((e) =>
        e ? ModelVersionTag.toJSON(e) : undefined
      );
    } else {
      obj.tags = [];
    }
    message.runLink !== undefined && (obj.runLink = message.runLink);
    message.description !== undefined &&
      (obj.description = message.description);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<CreateModelVersion>, I>>(
    object: I
  ): CreateModelVersion {
    const message = createBaseCreateModelVersion();
    message.name = object.name ?? "";
    message.source = object.source ?? "";
    message.runId = object.runId ?? "";
    message.tags =
      object.tags?.map((e) => ModelVersionTag.fromPartial(e)) || [];
    message.runLink = object.runLink ?? "";
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseCreateModelVersion_Response(): CreateModelVersion_Response {
  return { modelVersion: undefined };
}

export const CreateModelVersion_Response = {
  encode(
    message: CreateModelVersion_Response,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.modelVersion !== undefined) {
      ModelVersion.encode(
        message.modelVersion,
        writer.uint32(10).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): CreateModelVersion_Response {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateModelVersion_Response();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.modelVersion = ModelVersion.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CreateModelVersion_Response {
    return {
      modelVersion: isSet(object.modelVersion)
        ? ModelVersion.fromJSON(object.modelVersion)
        : undefined,
    };
  },

  toJSON(message: CreateModelVersion_Response): unknown {
    const obj: any = {};
    message.modelVersion !== undefined &&
      (obj.modelVersion = message.modelVersion
        ? ModelVersion.toJSON(message.modelVersion)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<CreateModelVersion_Response>, I>>(
    object: I
  ): CreateModelVersion_Response {
    const message = createBaseCreateModelVersion_Response();
    message.modelVersion =
      object.modelVersion !== undefined && object.modelVersion !== null
        ? ModelVersion.fromPartial(object.modelVersion)
        : undefined;
    return message;
  },
};

function createBaseUpdateModelVersion(): UpdateModelVersion {
  return { name: "", version: "", description: "" };
}

export const UpdateModelVersion = {
  encode(
    message: UpdateModelVersion,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateModelVersion {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateModelVersion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.version = reader.string();
          break;
        case 3:
          message.description = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): UpdateModelVersion {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      version: isSet(object.version) ? String(object.version) : "",
      description: isSet(object.description) ? String(object.description) : "",
    };
  },

  toJSON(message: UpdateModelVersion): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.version !== undefined && (obj.version = message.version);
    message.description !== undefined &&
      (obj.description = message.description);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<UpdateModelVersion>, I>>(
    object: I
  ): UpdateModelVersion {
    const message = createBaseUpdateModelVersion();
    message.name = object.name ?? "";
    message.version = object.version ?? "";
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseUpdateModelVersion_Response(): UpdateModelVersion_Response {
  return { modelVersion: undefined };
}

export const UpdateModelVersion_Response = {
  encode(
    message: UpdateModelVersion_Response,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.modelVersion !== undefined) {
      ModelVersion.encode(
        message.modelVersion,
        writer.uint32(10).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): UpdateModelVersion_Response {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateModelVersion_Response();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.modelVersion = ModelVersion.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): UpdateModelVersion_Response {
    return {
      modelVersion: isSet(object.modelVersion)
        ? ModelVersion.fromJSON(object.modelVersion)
        : undefined,
    };
  },

  toJSON(message: UpdateModelVersion_Response): unknown {
    const obj: any = {};
    message.modelVersion !== undefined &&
      (obj.modelVersion = message.modelVersion
        ? ModelVersion.toJSON(message.modelVersion)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<UpdateModelVersion_Response>, I>>(
    object: I
  ): UpdateModelVersion_Response {
    const message = createBaseUpdateModelVersion_Response();
    message.modelVersion =
      object.modelVersion !== undefined && object.modelVersion !== null
        ? ModelVersion.fromPartial(object.modelVersion)
        : undefined;
    return message;
  },
};

function createBaseTransitionModelVersionStage(): TransitionModelVersionStage {
  return { name: "", version: "", stage: "", archiveExistingVersions: false };
}

export const TransitionModelVersionStage = {
  encode(
    message: TransitionModelVersionStage,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    if (message.stage !== "") {
      writer.uint32(26).string(message.stage);
    }
    if (message.archiveExistingVersions === true) {
      writer.uint32(32).bool(message.archiveExistingVersions);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): TransitionModelVersionStage {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransitionModelVersionStage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.version = reader.string();
          break;
        case 3:
          message.stage = reader.string();
          break;
        case 4:
          message.archiveExistingVersions = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): TransitionModelVersionStage {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      version: isSet(object.version) ? String(object.version) : "",
      stage: isSet(object.stage) ? String(object.stage) : "",
      archiveExistingVersions: isSet(object.archiveExistingVersions)
        ? Boolean(object.archiveExistingVersions)
        : false,
    };
  },

  toJSON(message: TransitionModelVersionStage): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.version !== undefined && (obj.version = message.version);
    message.stage !== undefined && (obj.stage = message.stage);
    message.archiveExistingVersions !== undefined &&
      (obj.archiveExistingVersions = message.archiveExistingVersions);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<TransitionModelVersionStage>, I>>(
    object: I
  ): TransitionModelVersionStage {
    const message = createBaseTransitionModelVersionStage();
    message.name = object.name ?? "";
    message.version = object.version ?? "";
    message.stage = object.stage ?? "";
    message.archiveExistingVersions = object.archiveExistingVersions ?? false;
    return message;
  },
};

function createBaseTransitionModelVersionStage_Response(): TransitionModelVersionStage_Response {
  return { modelVersion: undefined };
}

export const TransitionModelVersionStage_Response = {
  encode(
    message: TransitionModelVersionStage_Response,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.modelVersion !== undefined) {
      ModelVersion.encode(
        message.modelVersion,
        writer.uint32(10).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): TransitionModelVersionStage_Response {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransitionModelVersionStage_Response();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.modelVersion = ModelVersion.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): TransitionModelVersionStage_Response {
    return {
      modelVersion: isSet(object.modelVersion)
        ? ModelVersion.fromJSON(object.modelVersion)
        : undefined,
    };
  },

  toJSON(message: TransitionModelVersionStage_Response): unknown {
    const obj: any = {};
    message.modelVersion !== undefined &&
      (obj.modelVersion = message.modelVersion
        ? ModelVersion.toJSON(message.modelVersion)
        : undefined);
    return obj;
  },

  fromPartial<
    I extends Exact<DeepPartial<TransitionModelVersionStage_Response>, I>
  >(object: I): TransitionModelVersionStage_Response {
    const message = createBaseTransitionModelVersionStage_Response();
    message.modelVersion =
      object.modelVersion !== undefined && object.modelVersion !== null
        ? ModelVersion.fromPartial(object.modelVersion)
        : undefined;
    return message;
  },
};

function createBaseDeleteModelVersion(): DeleteModelVersion {
  return { name: "", version: "" };
}

export const DeleteModelVersion = {
  encode(
    message: DeleteModelVersion,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteModelVersion {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteModelVersion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.version = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DeleteModelVersion {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      version: isSet(object.version) ? String(object.version) : "",
    };
  },

  toJSON(message: DeleteModelVersion): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.version !== undefined && (obj.version = message.version);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<DeleteModelVersion>, I>>(
    object: I
  ): DeleteModelVersion {
    const message = createBaseDeleteModelVersion();
    message.name = object.name ?? "";
    message.version = object.version ?? "";
    return message;
  },
};

function createBaseDeleteModelVersion_Response(): DeleteModelVersion_Response {
  return {};
}

export const DeleteModelVersion_Response = {
  encode(
    _: DeleteModelVersion_Response,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): DeleteModelVersion_Response {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteModelVersion_Response();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): DeleteModelVersion_Response {
    return {};
  },

  toJSON(_: DeleteModelVersion_Response): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<DeleteModelVersion_Response>, I>>(
    _: I
  ): DeleteModelVersion_Response {
    const message = createBaseDeleteModelVersion_Response();
    return message;
  },
};

function createBaseGetModelVersion(): GetModelVersion {
  return { name: "", version: "" };
}

export const GetModelVersion = {
  encode(
    message: GetModelVersion,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetModelVersion {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetModelVersion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.version = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetModelVersion {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      version: isSet(object.version) ? String(object.version) : "",
    };
  },

  toJSON(message: GetModelVersion): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.version !== undefined && (obj.version = message.version);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetModelVersion>, I>>(
    object: I
  ): GetModelVersion {
    const message = createBaseGetModelVersion();
    message.name = object.name ?? "";
    message.version = object.version ?? "";
    return message;
  },
};

function createBaseGetModelVersion_Response(): GetModelVersion_Response {
  return { modelVersion: undefined };
}

export const GetModelVersion_Response = {
  encode(
    message: GetModelVersion_Response,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.modelVersion !== undefined) {
      ModelVersion.encode(
        message.modelVersion,
        writer.uint32(10).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GetModelVersion_Response {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetModelVersion_Response();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.modelVersion = ModelVersion.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetModelVersion_Response {
    return {
      modelVersion: isSet(object.modelVersion)
        ? ModelVersion.fromJSON(object.modelVersion)
        : undefined,
    };
  },

  toJSON(message: GetModelVersion_Response): unknown {
    const obj: any = {};
    message.modelVersion !== undefined &&
      (obj.modelVersion = message.modelVersion
        ? ModelVersion.toJSON(message.modelVersion)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetModelVersion_Response>, I>>(
    object: I
  ): GetModelVersion_Response {
    const message = createBaseGetModelVersion_Response();
    message.modelVersion =
      object.modelVersion !== undefined && object.modelVersion !== null
        ? ModelVersion.fromPartial(object.modelVersion)
        : undefined;
    return message;
  },
};

function createBaseSearchModelVersions(): SearchModelVersions {
  return { filter: "", maxResults: 0, orderBy: [], pageToken: "" };
}

export const SearchModelVersions = {
  encode(
    message: SearchModelVersions,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.filter !== "") {
      writer.uint32(10).string(message.filter);
    }
    if (message.maxResults !== 0) {
      writer.uint32(16).int64(message.maxResults);
    }
    for (const v of message.orderBy) {
      writer.uint32(26).string(v!);
    }
    if (message.pageToken !== "") {
      writer.uint32(34).string(message.pageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SearchModelVersions {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchModelVersions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.filter = reader.string();
          break;
        case 2:
          message.maxResults = longToNumber(reader.int64() as Long);
          break;
        case 3:
          message.orderBy.push(reader.string());
          break;
        case 4:
          message.pageToken = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SearchModelVersions {
    return {
      filter: isSet(object.filter) ? String(object.filter) : "",
      maxResults: isSet(object.maxResults) ? Number(object.maxResults) : 0,
      orderBy: Array.isArray(object?.orderBy)
        ? object.orderBy.map((e: any) => String(e))
        : [],
      pageToken: isSet(object.pageToken) ? String(object.pageToken) : "",
    };
  },

  toJSON(message: SearchModelVersions): unknown {
    const obj: any = {};
    message.filter !== undefined && (obj.filter = message.filter);
    message.maxResults !== undefined &&
      (obj.maxResults = Math.round(message.maxResults));
    if (message.orderBy) {
      obj.orderBy = message.orderBy.map((e) => e);
    } else {
      obj.orderBy = [];
    }
    message.pageToken !== undefined && (obj.pageToken = message.pageToken);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SearchModelVersions>, I>>(
    object: I
  ): SearchModelVersions {
    const message = createBaseSearchModelVersions();
    message.filter = object.filter ?? "";
    message.maxResults = object.maxResults ?? 0;
    message.orderBy = object.orderBy?.map((e) => e) || [];
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseSearchModelVersions_Response(): SearchModelVersions_Response {
  return { modelVersions: [], nextPageToken: "" };
}

export const SearchModelVersions_Response = {
  encode(
    message: SearchModelVersions_Response,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    for (const v of message.modelVersions) {
      ModelVersion.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): SearchModelVersions_Response {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchModelVersions_Response();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.modelVersions.push(
            ModelVersion.decode(reader, reader.uint32())
          );
          break;
        case 2:
          message.nextPageToken = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SearchModelVersions_Response {
    return {
      modelVersions: Array.isArray(object?.modelVersions)
        ? object.modelVersions.map((e: any) => ModelVersion.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken)
        ? String(object.nextPageToken)
        : "",
    };
  },

  toJSON(message: SearchModelVersions_Response): unknown {
    const obj: any = {};
    if (message.modelVersions) {
      obj.modelVersions = message.modelVersions.map((e) =>
        e ? ModelVersion.toJSON(e) : undefined
      );
    } else {
      obj.modelVersions = [];
    }
    message.nextPageToken !== undefined &&
      (obj.nextPageToken = message.nextPageToken);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SearchModelVersions_Response>, I>>(
    object: I
  ): SearchModelVersions_Response {
    const message = createBaseSearchModelVersions_Response();
    message.modelVersions =
      object.modelVersions?.map((e) => ModelVersion.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetModelVersionDownloadUri(): GetModelVersionDownloadUri {
  return { name: "", version: "" };
}

export const GetModelVersionDownloadUri = {
  encode(
    message: GetModelVersionDownloadUri,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GetModelVersionDownloadUri {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetModelVersionDownloadUri();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.version = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetModelVersionDownloadUri {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      version: isSet(object.version) ? String(object.version) : "",
    };
  },

  toJSON(message: GetModelVersionDownloadUri): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.version !== undefined && (obj.version = message.version);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetModelVersionDownloadUri>, I>>(
    object: I
  ): GetModelVersionDownloadUri {
    const message = createBaseGetModelVersionDownloadUri();
    message.name = object.name ?? "";
    message.version = object.version ?? "";
    return message;
  },
};

function createBaseGetModelVersionDownloadUri_Response(): GetModelVersionDownloadUri_Response {
  return { artifactUri: "" };
}

export const GetModelVersionDownloadUri_Response = {
  encode(
    message: GetModelVersionDownloadUri_Response,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.artifactUri !== "") {
      writer.uint32(10).string(message.artifactUri);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GetModelVersionDownloadUri_Response {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetModelVersionDownloadUri_Response();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.artifactUri = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetModelVersionDownloadUri_Response {
    return {
      artifactUri: isSet(object.artifactUri) ? String(object.artifactUri) : "",
    };
  },

  toJSON(message: GetModelVersionDownloadUri_Response): unknown {
    const obj: any = {};
    message.artifactUri !== undefined &&
      (obj.artifactUri = message.artifactUri);
    return obj;
  },

  fromPartial<
    I extends Exact<DeepPartial<GetModelVersionDownloadUri_Response>, I>
  >(object: I): GetModelVersionDownloadUri_Response {
    const message = createBaseGetModelVersionDownloadUri_Response();
    message.artifactUri = object.artifactUri ?? "";
    return message;
  },
};

function createBaseModelVersionTag(): ModelVersionTag {
  return { key: "", value: "" };
}

export const ModelVersionTag = {
  encode(
    message: ModelVersionTag,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ModelVersionTag {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelVersionTag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ModelVersionTag {
    return {
      key: isSet(object.key) ? String(object.key) : "",
      value: isSet(object.value) ? String(object.value) : "",
    };
  },

  toJSON(message: ModelVersionTag): unknown {
    const obj: any = {};
    message.key !== undefined && (obj.key = message.key);
    message.value !== undefined && (obj.value = message.value);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ModelVersionTag>, I>>(
    object: I
  ): ModelVersionTag {
    const message = createBaseModelVersionTag();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseRegisteredModelTag(): RegisteredModelTag {
  return { key: "", value: "" };
}

export const RegisteredModelTag = {
  encode(
    message: RegisteredModelTag,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RegisteredModelTag {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisteredModelTag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RegisteredModelTag {
    return {
      key: isSet(object.key) ? String(object.key) : "",
      value: isSet(object.value) ? String(object.value) : "",
    };
  },

  toJSON(message: RegisteredModelTag): unknown {
    const obj: any = {};
    message.key !== undefined && (obj.key = message.key);
    message.value !== undefined && (obj.value = message.value);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<RegisteredModelTag>, I>>(
    object: I
  ): RegisteredModelTag {
    const message = createBaseRegisteredModelTag();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSetRegisteredModelTag(): SetRegisteredModelTag {
  return { name: "", key: "", value: "" };
}

export const SetRegisteredModelTag = {
  encode(
    message: SetRegisteredModelTag,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(26).string(message.value);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): SetRegisteredModelTag {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetRegisteredModelTag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.key = reader.string();
          break;
        case 3:
          message.value = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SetRegisteredModelTag {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      key: isSet(object.key) ? String(object.key) : "",
      value: isSet(object.value) ? String(object.value) : "",
    };
  },

  toJSON(message: SetRegisteredModelTag): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.key !== undefined && (obj.key = message.key);
    message.value !== undefined && (obj.value = message.value);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SetRegisteredModelTag>, I>>(
    object: I
  ): SetRegisteredModelTag {
    const message = createBaseSetRegisteredModelTag();
    message.name = object.name ?? "";
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSetRegisteredModelTag_Response(): SetRegisteredModelTag_Response {
  return {};
}

export const SetRegisteredModelTag_Response = {
  encode(
    _: SetRegisteredModelTag_Response,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): SetRegisteredModelTag_Response {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetRegisteredModelTag_Response();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): SetRegisteredModelTag_Response {
    return {};
  },

  toJSON(_: SetRegisteredModelTag_Response): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SetRegisteredModelTag_Response>, I>>(
    _: I
  ): SetRegisteredModelTag_Response {
    const message = createBaseSetRegisteredModelTag_Response();
    return message;
  },
};

function createBaseSetModelVersionTag(): SetModelVersionTag {
  return { name: "", version: "", key: "", value: "" };
}

export const SetModelVersionTag = {
  encode(
    message: SetModelVersionTag,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    if (message.key !== "") {
      writer.uint32(26).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(34).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SetModelVersionTag {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetModelVersionTag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.version = reader.string();
          break;
        case 3:
          message.key = reader.string();
          break;
        case 4:
          message.value = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SetModelVersionTag {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      version: isSet(object.version) ? String(object.version) : "",
      key: isSet(object.key) ? String(object.key) : "",
      value: isSet(object.value) ? String(object.value) : "",
    };
  },

  toJSON(message: SetModelVersionTag): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.version !== undefined && (obj.version = message.version);
    message.key !== undefined && (obj.key = message.key);
    message.value !== undefined && (obj.value = message.value);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SetModelVersionTag>, I>>(
    object: I
  ): SetModelVersionTag {
    const message = createBaseSetModelVersionTag();
    message.name = object.name ?? "";
    message.version = object.version ?? "";
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSetModelVersionTag_Response(): SetModelVersionTag_Response {
  return {};
}

export const SetModelVersionTag_Response = {
  encode(
    _: SetModelVersionTag_Response,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): SetModelVersionTag_Response {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetModelVersionTag_Response();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): SetModelVersionTag_Response {
    return {};
  },

  toJSON(_: SetModelVersionTag_Response): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SetModelVersionTag_Response>, I>>(
    _: I
  ): SetModelVersionTag_Response {
    const message = createBaseSetModelVersionTag_Response();
    return message;
  },
};

function createBaseDeleteRegisteredModelTag(): DeleteRegisteredModelTag {
  return { name: "", key: "" };
}

export const DeleteRegisteredModelTag = {
  encode(
    message: DeleteRegisteredModelTag,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): DeleteRegisteredModelTag {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteRegisteredModelTag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.key = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DeleteRegisteredModelTag {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      key: isSet(object.key) ? String(object.key) : "",
    };
  },

  toJSON(message: DeleteRegisteredModelTag): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.key !== undefined && (obj.key = message.key);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<DeleteRegisteredModelTag>, I>>(
    object: I
  ): DeleteRegisteredModelTag {
    const message = createBaseDeleteRegisteredModelTag();
    message.name = object.name ?? "";
    message.key = object.key ?? "";
    return message;
  },
};

function createBaseDeleteRegisteredModelTag_Response(): DeleteRegisteredModelTag_Response {
  return {};
}

export const DeleteRegisteredModelTag_Response = {
  encode(
    _: DeleteRegisteredModelTag_Response,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): DeleteRegisteredModelTag_Response {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteRegisteredModelTag_Response();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): DeleteRegisteredModelTag_Response {
    return {};
  },

  toJSON(_: DeleteRegisteredModelTag_Response): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<
    I extends Exact<DeepPartial<DeleteRegisteredModelTag_Response>, I>
  >(_: I): DeleteRegisteredModelTag_Response {
    const message = createBaseDeleteRegisteredModelTag_Response();
    return message;
  },
};

function createBaseDeleteModelVersionTag(): DeleteModelVersionTag {
  return { name: "", version: "", key: "" };
}

export const DeleteModelVersionTag = {
  encode(
    message: DeleteModelVersionTag,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    if (message.key !== "") {
      writer.uint32(26).string(message.key);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): DeleteModelVersionTag {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteModelVersionTag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.version = reader.string();
          break;
        case 3:
          message.key = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DeleteModelVersionTag {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      version: isSet(object.version) ? String(object.version) : "",
      key: isSet(object.key) ? String(object.key) : "",
    };
  },

  toJSON(message: DeleteModelVersionTag): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.version !== undefined && (obj.version = message.version);
    message.key !== undefined && (obj.key = message.key);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<DeleteModelVersionTag>, I>>(
    object: I
  ): DeleteModelVersionTag {
    const message = createBaseDeleteModelVersionTag();
    message.name = object.name ?? "";
    message.version = object.version ?? "";
    message.key = object.key ?? "";
    return message;
  },
};

function createBaseDeleteModelVersionTag_Response(): DeleteModelVersionTag_Response {
  return {};
}

export const DeleteModelVersionTag_Response = {
  encode(
    _: DeleteModelVersionTag_Response,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): DeleteModelVersionTag_Response {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteModelVersionTag_Response();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): DeleteModelVersionTag_Response {
    return {};
  },

  toJSON(_: DeleteModelVersionTag_Response): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<DeleteModelVersionTag_Response>, I>>(
    _: I
  ): DeleteModelVersionTag_Response {
    const message = createBaseDeleteModelVersionTag_Response();
    return message;
  },
};

export interface ModelRegistryService {
  /** Throws ``RESOURCE_ALREADY_EXISTS`` if a registered model with the given name exists. */
  createRegisteredModel(
    request: CreateRegisteredModel
  ): Promise<CreateRegisteredModel_Response>;
  renameRegisteredModel(
    request: RenameRegisteredModel
  ): Promise<RenameRegisteredModel_Response>;
  updateRegisteredModel(
    request: UpdateRegisteredModel
  ): Promise<UpdateRegisteredModel_Response>;
  deleteRegisteredModel(
    request: DeleteRegisteredModel
  ): Promise<DeleteRegisteredModel_Response>;
  getRegisteredModel(
    request: GetRegisteredModel
  ): Promise<GetRegisteredModel_Response>;
  searchRegisteredModels(
    request: SearchRegisteredModels
  ): Promise<SearchRegisteredModels_Response>;
  listRegisteredModels(
    request: ListRegisteredModels
  ): Promise<ListRegisteredModels_Response>;
  getLatestVersions(
    request: GetLatestVersions
  ): Promise<GetLatestVersions_Response>;
  createModelVersion(
    request: CreateModelVersion
  ): Promise<CreateModelVersion_Response>;
  updateModelVersion(
    request: UpdateModelVersion
  ): Promise<UpdateModelVersion_Response>;
  transitionModelVersionStage(
    request: TransitionModelVersionStage
  ): Promise<TransitionModelVersionStage_Response>;
  deleteModelVersion(
    request: DeleteModelVersion
  ): Promise<DeleteModelVersion_Response>;
  getModelVersion(request: GetModelVersion): Promise<GetModelVersion_Response>;
  searchModelVersions(
    request: SearchModelVersions
  ): Promise<SearchModelVersions_Response>;
  getModelVersionDownloadUri(
    request: GetModelVersionDownloadUri
  ): Promise<GetModelVersionDownloadUri_Response>;
  setRegisteredModelTag(
    request: SetRegisteredModelTag
  ): Promise<SetRegisteredModelTag_Response>;
  setModelVersionTag(
    request: SetModelVersionTag
  ): Promise<SetModelVersionTag_Response>;
  deleteRegisteredModelTag(
    request: DeleteRegisteredModelTag
  ): Promise<DeleteRegisteredModelTag_Response>;
  deleteModelVersionTag(
    request: DeleteModelVersionTag
  ): Promise<DeleteModelVersionTag_Response>;
}

export class ModelRegistryServiceClientImpl implements ModelRegistryService {
  private readonly rpc: Rpc;
  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.createRegisteredModel = this.createRegisteredModel.bind(this);
    this.renameRegisteredModel = this.renameRegisteredModel.bind(this);
    this.updateRegisteredModel = this.updateRegisteredModel.bind(this);
    this.deleteRegisteredModel = this.deleteRegisteredModel.bind(this);
    this.getRegisteredModel = this.getRegisteredModel.bind(this);
    this.searchRegisteredModels = this.searchRegisteredModels.bind(this);
    this.listRegisteredModels = this.listRegisteredModels.bind(this);
    this.getLatestVersions = this.getLatestVersions.bind(this);
    this.createModelVersion = this.createModelVersion.bind(this);
    this.updateModelVersion = this.updateModelVersion.bind(this);
    this.transitionModelVersionStage =
      this.transitionModelVersionStage.bind(this);
    this.deleteModelVersion = this.deleteModelVersion.bind(this);
    this.getModelVersion = this.getModelVersion.bind(this);
    this.searchModelVersions = this.searchModelVersions.bind(this);
    this.getModelVersionDownloadUri =
      this.getModelVersionDownloadUri.bind(this);
    this.setRegisteredModelTag = this.setRegisteredModelTag.bind(this);
    this.setModelVersionTag = this.setModelVersionTag.bind(this);
    this.deleteRegisteredModelTag = this.deleteRegisteredModelTag.bind(this);
    this.deleteModelVersionTag = this.deleteModelVersionTag.bind(this);
  }
  createRegisteredModel(
    request: CreateRegisteredModel
  ): Promise<CreateRegisteredModel_Response> {
    const data = CreateRegisteredModel.encode(request).finish();
    const promise = this.rpc.request(
      "mlflow.ModelRegistryService",
      "createRegisteredModel",
      data
    );
    return promise.then((data) =>
      CreateRegisteredModel_Response.decode(new _m0.Reader(data))
    );
  }

  renameRegisteredModel(
    request: RenameRegisteredModel
  ): Promise<RenameRegisteredModel_Response> {
    const data = RenameRegisteredModel.encode(request).finish();
    const promise = this.rpc.request(
      "mlflow.ModelRegistryService",
      "renameRegisteredModel",
      data
    );
    return promise.then((data) =>
      RenameRegisteredModel_Response.decode(new _m0.Reader(data))
    );
  }

  updateRegisteredModel(
    request: UpdateRegisteredModel
  ): Promise<UpdateRegisteredModel_Response> {
    const data = UpdateRegisteredModel.encode(request).finish();
    const promise = this.rpc.request(
      "mlflow.ModelRegistryService",
      "updateRegisteredModel",
      data
    );
    return promise.then((data) =>
      UpdateRegisteredModel_Response.decode(new _m0.Reader(data))
    );
  }

  deleteRegisteredModel(
    request: DeleteRegisteredModel
  ): Promise<DeleteRegisteredModel_Response> {
    const data = DeleteRegisteredModel.encode(request).finish();
    const promise = this.rpc.request(
      "mlflow.ModelRegistryService",
      "deleteRegisteredModel",
      data
    );
    return promise.then((data) =>
      DeleteRegisteredModel_Response.decode(new _m0.Reader(data))
    );
  }

  getRegisteredModel(
    request: GetRegisteredModel
  ): Promise<GetRegisteredModel_Response> {
    const data = GetRegisteredModel.encode(request).finish();
    const promise = this.rpc.request(
      "mlflow.ModelRegistryService",
      "getRegisteredModel",
      data
    );
    return promise.then((data) =>
      GetRegisteredModel_Response.decode(new _m0.Reader(data))
    );
  }

  searchRegisteredModels(
    request: SearchRegisteredModels
  ): Promise<SearchRegisteredModels_Response> {
    const data = SearchRegisteredModels.encode(request).finish();
    const promise = this.rpc.request(
      "mlflow.ModelRegistryService",
      "searchRegisteredModels",
      data
    );
    return promise.then((data) =>
      SearchRegisteredModels_Response.decode(new _m0.Reader(data))
    );
  }

  listRegisteredModels(
    request: ListRegisteredModels
  ): Promise<ListRegisteredModels_Response> {
    const data = ListRegisteredModels.encode(request).finish();
    const promise = this.rpc.request(
      "mlflow.ModelRegistryService",
      "listRegisteredModels",
      data
    );
    return promise.then((data) =>
      ListRegisteredModels_Response.decode(new _m0.Reader(data))
    );
  }

  getLatestVersions(
    request: GetLatestVersions
  ): Promise<GetLatestVersions_Response> {
    const data = GetLatestVersions.encode(request).finish();
    const promise = this.rpc.request(
      "mlflow.ModelRegistryService",
      "getLatestVersions",
      data
    );
    return promise.then((data) =>
      GetLatestVersions_Response.decode(new _m0.Reader(data))
    );
  }

  createModelVersion(
    request: CreateModelVersion
  ): Promise<CreateModelVersion_Response> {
    const data = CreateModelVersion.encode(request).finish();
    const promise = this.rpc.request(
      "mlflow.ModelRegistryService",
      "createModelVersion",
      data
    );
    return promise.then((data) =>
      CreateModelVersion_Response.decode(new _m0.Reader(data))
    );
  }

  updateModelVersion(
    request: UpdateModelVersion
  ): Promise<UpdateModelVersion_Response> {
    const data = UpdateModelVersion.encode(request).finish();
    const promise = this.rpc.request(
      "mlflow.ModelRegistryService",
      "updateModelVersion",
      data
    );
    return promise.then((data) =>
      UpdateModelVersion_Response.decode(new _m0.Reader(data))
    );
  }

  transitionModelVersionStage(
    request: TransitionModelVersionStage
  ): Promise<TransitionModelVersionStage_Response> {
    const data = TransitionModelVersionStage.encode(request).finish();
    const promise = this.rpc.request(
      "mlflow.ModelRegistryService",
      "transitionModelVersionStage",
      data
    );
    return promise.then((data) =>
      TransitionModelVersionStage_Response.decode(new _m0.Reader(data))
    );
  }

  deleteModelVersion(
    request: DeleteModelVersion
  ): Promise<DeleteModelVersion_Response> {
    const data = DeleteModelVersion.encode(request).finish();
    const promise = this.rpc.request(
      "mlflow.ModelRegistryService",
      "deleteModelVersion",
      data
    );
    return promise.then((data) =>
      DeleteModelVersion_Response.decode(new _m0.Reader(data))
    );
  }

  getModelVersion(request: GetModelVersion): Promise<GetModelVersion_Response> {
    const data = GetModelVersion.encode(request).finish();
    const promise = this.rpc.request(
      "mlflow.ModelRegistryService",
      "getModelVersion",
      data
    );
    return promise.then((data) =>
      GetModelVersion_Response.decode(new _m0.Reader(data))
    );
  }

  searchModelVersions(
    request: SearchModelVersions
  ): Promise<SearchModelVersions_Response> {
    const data = SearchModelVersions.encode(request).finish();
    const promise = this.rpc.request(
      "mlflow.ModelRegistryService",
      "searchModelVersions",
      data
    );
    return promise.then((data) =>
      SearchModelVersions_Response.decode(new _m0.Reader(data))
    );
  }

  getModelVersionDownloadUri(
    request: GetModelVersionDownloadUri
  ): Promise<GetModelVersionDownloadUri_Response> {
    const data = GetModelVersionDownloadUri.encode(request).finish();
    const promise = this.rpc.request(
      "mlflow.ModelRegistryService",
      "getModelVersionDownloadUri",
      data
    );
    return promise.then((data) =>
      GetModelVersionDownloadUri_Response.decode(new _m0.Reader(data))
    );
  }

  setRegisteredModelTag(
    request: SetRegisteredModelTag
  ): Promise<SetRegisteredModelTag_Response> {
    const data = SetRegisteredModelTag.encode(request).finish();
    const promise = this.rpc.request(
      "mlflow.ModelRegistryService",
      "setRegisteredModelTag",
      data
    );
    return promise.then((data) =>
      SetRegisteredModelTag_Response.decode(new _m0.Reader(data))
    );
  }

  setModelVersionTag(
    request: SetModelVersionTag
  ): Promise<SetModelVersionTag_Response> {
    const data = SetModelVersionTag.encode(request).finish();
    const promise = this.rpc.request(
      "mlflow.ModelRegistryService",
      "setModelVersionTag",
      data
    );
    return promise.then((data) =>
      SetModelVersionTag_Response.decode(new _m0.Reader(data))
    );
  }

  deleteRegisteredModelTag(
    request: DeleteRegisteredModelTag
  ): Promise<DeleteRegisteredModelTag_Response> {
    const data = DeleteRegisteredModelTag.encode(request).finish();
    const promise = this.rpc.request(
      "mlflow.ModelRegistryService",
      "deleteRegisteredModelTag",
      data
    );
    return promise.then((data) =>
      DeleteRegisteredModelTag_Response.decode(new _m0.Reader(data))
    );
  }

  deleteModelVersionTag(
    request: DeleteModelVersionTag
  ): Promise<DeleteModelVersionTag_Response> {
    const data = DeleteModelVersionTag.encode(request).finish();
    const promise = this.rpc.request(
      "mlflow.ModelRegistryService",
      "deleteModelVersionTag",
      data
    );
    return promise.then((data) =>
      DeleteModelVersionTag_Response.decode(new _m0.Reader(data))
    );
  }
}

interface Rpc {
  request(
    service: string,
    method: string,
    data: Uint8Array
  ): Promise<Uint8Array>;
}

declare var self: any | undefined;
declare var window: any | undefined;
declare var global: any | undefined;
var globalThis: any = (() => {
  if (typeof globalThis !== "undefined") return globalThis;
  if (typeof self !== "undefined") return self;
  if (typeof window !== "undefined") return window;
  if (typeof global !== "undefined") return global;
  throw "Unable to locate global object";
})();

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends Array<infer U>
  ? Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U>
  ? ReadonlyArray<DeepPartial<U>>
  : T extends {}
  ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<
        Exclude<keyof I, KeysOfUnion<P>>,
        never
      >;

function longToNumber(long: Long): number {
  if (long.gt(Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}

// If you get a compile-error about 'Constructor<Long> and ... have no overlap',
// add '--ts_proto_opt=esModuleInterop=true' as a flag when calling 'protoc'.
if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
